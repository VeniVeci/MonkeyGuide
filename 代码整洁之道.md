Bob大叔：

# 必读引言

主要讲Bob大叔的职业生涯，讲他犯了很多错误。

当时他编程居然用的是最老的卡片，打孔机这些东西

![image.png](./assets/1701182550530-image.png)

![image.png](./assets/1701182641150-image.png)

# 第1章 专业主义

所谓专业人士，就是能对自己犯下的错误负责的人，哪怕那些错误实际上在所难免。所以，雄心勃勃的专业人士们，你们要练习的第一件事就是“道歉”。道歉是必要的，但还不够。你不能一而再、再而三地犯相同的错误。职业经验多了之后，你的失误率应该快速减少，甚至渐近于零。失误率永远不可能等于零，但你有责任让它无限接近零。

发布软件时，你应该确保QA找不出任何问题。故意发送明知有缺陷的代码，这种做法是极其不专业的。什么样的代码是有缺陷的呢？那些你没把握的代码都是！有些家伙会把QA当作啄木鸟看待。他们把自己没有全盘检查过的代码发送过去，想等QA找出bug再反馈回来。没错，有些公司确实按照所发现的bug数来奖励测试人员，揪出的bug越多，奖金越多。

要确信代码正常运行你怎么知道代码能否常运行呢？很简单，测试！一遍遍地测，翻来覆去、颠来倒去地测，使出浑身解数来测！你或许会担心这么狂测代码会占用很多时间，毕竟，你还要赶进度，要在截止日期前完工。如果不停地花时间做测试，你就没时间写别的代码了。言之有理！所以要实行自动化测试。写一些随时都能运行的单元测试，然后尽可能多地执行这些测试。要用这些自动化单元测试去测多少代码呢？还要说吗？全部！全部都要测！

我是开源项目FitNesse的主要贡献者和代码提交者。在写作本书的时候，FitNesse的代码有6万多行。在这6万行代码中有2000多个单元测试，超过2.6万行。Emma的报告显示，这2000多个测试对代码的覆盖率约为90%。为什么只有90%呢？因为Emma会忽略一些执行的代码。我确信实际的覆盖率会比90%高许多。能达到100%吗？不，达不到，100%只是个理想值。但是有些代码不是很难测试吗？是的，但之所以很难测试，是因为设计时就没考虑如何测试。唯一的解决办法就是要设计易于测试的代码，最好是先写测试，再写要测的代码。

43%的代码都是测试代码

但是有些代码不是很难测试吗？是的，但之所以很难测试，是因为设计时就没考虑如何测试。唯一的解决办法就是要设计易于测试的代码，最好是先写测试，再写要测的代码。这一方法叫做测试驱动开发（TDD）

## 自动化QA

FitNesse的整个QA流程即是执行单元测试和验收测试。如果这些测试通过了，我就会发布软件。这意味着我的QA流程大概需要3分钟，只要我想要，可以随时执行完整的测试流程。没错，FitNesse即使有bug也不是什么人命关天的事，也不会有人为此损失几百万美元。值得一提的是FitNesse用户上万，但它的bug列表却很短。

不要破坏结构成熟的专业开发人员知道，聪明人不会为了发布新功能而破坏结构。结构良好的代码更灵活。以牺牲结构为代价，得不偿失，将来必追悔莫及。所有软件项目的根本指导原则是，软件要易于修改。如果违背这条原则搭建僵化的结构，就破坏了构筑整个行业的经济模型。

描述如何创建灵活可维护的结构的软件设计原则和模式[2]已经有许多了。专业的软件开发人员会牢记这些原则和模式，并在开发软件时认真遵循。但是其中有一条实在是没几个软件开发人员会认真照做，那就是，如果你希望自己的软件灵活可变，

每次通读代码的时候，也可以不时调整一下结构。这一策略有时也叫“无情重构”，我把它叫作“童子军训练守则”：对每个模块，每检入一次代码，就要让它比上次检出时变得更为简洁。每次读代码，都别忘了进行点滴的改善。这完全与大多数人对软件的理解相反。他们认为对上线运行的软件不断地做修改是危险的。错！让软件保持固定不变才是危险的！如果一直不重构代码，等到最后不得不重构时，你就会发现代码已经“僵化了”。

为什么大多数开发人员不敢不断修改他的代码呢？因为他们害怕会改坏代码！为什么会有这样的担心呢？因为他们没做过测试。话题又回到测试上来了。如果你有一套覆盖了全部代码的自动化测试，如果那套测试可以随时快速执行，那么你根本不会害怕修改代码。怎样才能证明你不怕修改代码呢？那就是，你一直在改。专业开发人员对自己的代码和测试极有把握，他们会极其疯狂随意地做各种修改。他们敢于随心所欲修改类的名称。在通读代码时，如果发现一个冗长的方法，他们肯定会将它拆分，重新组织。他们还会把switch语句改为多态结构，或者将继承层次重构成一条“命令链”。简单地说，他们对待代码，就如同雕塑家对待泥巴那样，要对它进行不断的变形与塑造。

## kata

卡塔的形式往往是一个有待解决的简单编程问题，比如编写计算拆分某个整数的素数因子等。练卡塔的目的不是找出解决方法（你已经知道方法了），而是训练你的手指和大脑。每天我都会练一两个卡塔，时间往往安排在正式投入工作之前。我可能会选用Java、Ruby、Clojure或其他我希望保持纯熟的语言来练习。我会用卡塔来培养某种专门的技能，比如让我的手指习惯点击快捷键或习惯使用某些重构技法等。不妨早晚都来个10分钟的卡塔吧，把它当作热身练习或者静心过程。

# 第2章　说“不”

“能就是能，不能就是不能。不要说‘试试看’。”——尤达

事情就这么开始了。尽管多年来我时常提醒自己——客户所要的任何一项功能，一旦写起来，总是远比它开始时所说的要复杂许多，但最终你还是会接下这些活。我居然天真地相信自己真的能在两周内完成开发。是的！我们能搞定！这次与以往不同！只是简单的图片展示，以及通过服务调用获取门店地址而已

# 第5章　测试驱动开发

“测试驱动开发”（TDD）自在行业中首次亮相，至今已经有十余年了。它最早是极限编程（XP）运动的一部分，但此后已经被Scrum和几乎所有其他敏捷方法所采纳。即使是非敏捷的团队也在实践TDD。

Kent和我坐在他的办公室里，使用Java语言解决一些小问题。我一上来就只想马上写能够解决这个小问题的代码。但是Kent不让我这么做，而是带着我一步步体验了TDD的整个过程。首先，他写了一个单元测试的一小部分，没几行代码。然后，他写了刚好能使那个测试编译通过的代码。接着，他又写了些测试，然后再写一些代码。从编码到运行的周期如此之短完全超出了我的想象。我以前都是先花上大半个小时写代码，然后才去编译或运行。而Kent居然每30秒左右就会运行一次程序。这让我目瞪口呆！

与Kent交流后我领悟到：TDD绝不仅仅是一种用于缩短编码周期的简单技巧。我会在下文中详述TDD的诸多优势。

如果缺乏极高覆盖率的自动化单元测试，如何能够做到每次修改代码后都对代码进行测试？如果不采用TDD，如何能够获得极高覆盖率的自动化单元测试？

## 5.2　TDD的三项法则

（1）在编好失败单元测试之前，不要编写任何产品代码。（2）只要有一个单元测试失败了，就不要再写测试代码；无法通过编译也是一种失败情况。（3）产品代码恰好能够让当前失败的单元测试成功通过即可，不要多写。遵循这三项法则的话，大概30秒钟就要运行一次代码。先写好一个单元测试的一小部分代码，很快，你会发现还缺少一些类或函数，所以单元测试无法编译。因此必须编写产品代码，让这些测试能够编译成功。产品代码够用即可，然后再回头接着写单元测试代码。

这个循环不断反复。写一些测试代码，然后再写一些产品代码。这两套代码同步增长，互为补充。测试代码之匹配于产品代码，就如抗体之匹配于抗原一样

## 5.3　TDD的优势

### 5.3.1　确定性

如果将TDD作为一项行业纪律，那么每天要写上几十个测试，每周要写上成百上千个测试，每年写上成千上万个测试。任何时刻，代码有任何修改，都必须运行手头有的全部测试。

FitNesse是一个基于Java的验收测试工具，我是其主要作者和维护者。在我写本书时，FitNesse拥有6.4万行代码，其中2.8万行代码是单元测试代码，共计有超过2200个独立的单元测试用例。这些测试至少覆盖了90%的产品代码[2]，90秒便可以完整执行一遍。

自动化测试

针对业务场景 编写自动化测试代码

这样的话不就可以

### 5.3.2　缺陷注入率

现在，FitNesse还不是一个性命攸关的应用。如果有一个bug，也没人会因此送命，没人会因此损失数百万美元。因此无须更多判断，单凭测试全部通过，我便敢冒可能的风险发布代码。另一方面来说，FitNesse目前有成千上万的用户，尽管去年新增了2万行新代码，但是我的bug列表上只有17个bug（而且许多bug实质上是很表面的）。因此我很清楚自己的缺陷注入率是非常低的。这并非个案。有不少报告和研究[3]称TDD能够显著降低缺陷。

### 5.3.3　勇气

看到糟糕代码时，你为什么不修改呢？看到混乱的函数时，你的第一反应是：“真是一团糟，这个函数需要整理。”你的第二反应是：“我不会去碰它！”为什么？因为你知道，如果去动它，就要冒破坏它的风险；而如果你破坏了它，那么它就缠上你了。

### 5.3.4　文档

单元测试即是文档。它们描述了系统设计的最底层设计细节。它们清晰准确，以读者能够理解的语言写成，并且形式规整可以运行

### 5.3.5　设计

当你遵循三项法则并且做到了测试先行时，还会感到进退维谷。通常情况下，你对于想要写的代码十分清楚，但是三项法则却要求你先写出目前无法通过的单元测试，因为要测试的代码尚未诞生！这意味着必须测试将要编写的代码。测试代码的一个问题是必须隔离出待测试的代码。如果一个函数调用了其他函数，单独测试它通常会比较困难。为了编写测试，你必须找出将这个函数和其他函数解耦的办法。换言之，测试先行的需要，会迫使你去考虑什么是好的设计。如果不先写测试，就有可能出现各个函数耦合在一起最终变成无法测试的一大团的问题。如果后面再写测试，你也许能够测试整个大块的输入和输出，但是很难测试单个函数。

“但是我可以稍后再写测试啊。”你也许会这样说。不，不可能。实际上也不是绝对不可以，没错，你是能够稍后写些测试。如果很仔细地来看，也许后写测试还可以达到较高的覆盖率。但是事后写的测试只是一种防守。而先行编写的测试则是进攻，事后编写测试的作者已经受制于已有代码，他已经知道问题是如何解决的。

**与采用测试先行的方式编写的测试代码比起来，后写的测试在深度和捕获错误的灵敏度方面要逊色很多。**
