# 第一部分 基础思维能力

## 01 抽象思维

就是抽象 ，合理的抽象。

这部分主要介绍解决日常问题的基础思维能力。这些思维能力不受行业的局限，比如我们在解决数学问题时需要动用抽象思维和逻辑思维；结构化思维更多地被用在写作和表达中；在当今信息爆炸的时代，每个人都需要有一些批判精神，这是批判性思维；化繁为简是我们要一直追寻的目标，这需要具备简单思维；面对困难，要有成长型思维；等等。

1.1 抽象=抽离+具象在《西方哲学史》中，奥古斯丁说：“至于什么是时间，在没人问我时，我非常清楚；可一旦要向别人解释，我就有点糊涂了。”对于抽象的概念也是如此，很多人都介于“懂”但是又“说不清楚”的模棱两可状态，不妨让我们先从定义开始来揭开“抽象”的神秘面纱。

### 怎么起变量名

这也是我在做设计和代码审查(Code Review)的时候，会特别关注命名是否合理的原因。因为命名的好坏在很大程度上反映了我们对一个概念的思考是否清晰、抽象是否合理，反映在代码上就是代码的可读性、可理解性是否良好，以及我们的设计是否到位。有人做过一个调查，问程序员最头疼的事情是什么。Quora和Ubuntu Forum的调查结果显示，程序员最头疼的事情是命名。如果你曾经为了一个命名而绞尽脑汁，就不会对这个结果感到意外。正如Stack Overflow的创始人Joel Spolsky所说：“Creating good names is hard，but it should be hard，because a great name captures essential meaning in just one or two words.”（起一个好名字应该很难，因为，一个好名字需要把要义浓缩在一到两个词中。）

我想强调的是：语言是明晰概念的基础，也是抽象思维的基础，在构建一个系统时，值得我们花很多时间去斟酌和推敲语言。我曾经做过一个项目，在过程中针对一个关键实体讨论了两天，因为那是一个新概念，我们尝试了很多名字，却始终感觉别扭、不好理解。随着讨论和对问题域理解的深入，我们最终找到了一个相对比较合适的名字，才算罢休。这样的斟酌是有意义的，因为明晰关键概念是我们设计中的重要工作。虽然不合理的命名和不合理的抽象也能实现业务功能，但代价就是维护系统时的极高的认知负荷。随着时间的推移，也许就没人能搞懂系统为何这样设计了。

软件设计是单纯的思维创造活动，其中最关键的是抽象思维。可以说，抽象是软件设计的核心，特别是在面向对象设计中，如果没有好的抽象概念，就不可能设计和编写出好的面向对象(Object Oriented, OO)程序。1.4.1 面向对象的核心是抽象作为当今最重要的软件工程技术之一，面向对象(Object Oriented, OO)技术实际上由3个部分组成，分别是面向对象分析(Object Oriented Analysis, OOA)、面向对象设计(Object Oriented Design, OOD)和面向对象编程(Object Oriented Programming, OOP)。

### 如何抽象

1.4.4 抽象缺失之重复代码如果说抽象源于对共性的提取，那么代码中的重复代码是不是就意味着抽象缺失呢？重复代码是典型的代码坏味道，其本质问题就是抽象缺失。使用“Ctrl+C”加“Ctrl+V”的工作习惯导致没有对共性代码进行抽取，或者虽然抽取了，但没有设置一个合适的名字，没有正确地反映这段代码所体现的抽象概念，这些都属于抽象不到位。

由此可见，提取重复代码只是重构工作的第一步。对重复代码进行概念抽象，寻找有意义的命名才是我们工作的重点。因此，每次遇到重复代码需要重构的时候，你都应该感到兴奋，这是一次锻炼抽象能力的绝佳机会。

### 判断抽象是否完整

1.4.5 抽象设计要完整好的抽象设计是内聚而完整的。为了支持相关的方法，可能会影响抽象的内聚性和完整性。例如，要在数据结构中添加和删除元素，抽象该数据结构的类型必须同时支持方法add()和remove()；如果只支持相关方法中的一个，那么抽象设计就不是内聚和完整的。例如，在JDK 1.1的接口javax.swing.ButtonModel中，只提供了setGroup()方法，而没有提供getGroup()，这是一种典型的“不完整的抽象设计”坏味道。修复它的最理想的方法是在这个接口中定义方法getGroup()，然而由于JDK是公开的API，在接口上添加方法将破坏实现了该接口的既有类。为了向后兼容，在JDK 1.3中，将方法getGroup()加入了派生类DefaultButtonModel中。

### 中台的必要性： 是否是好的抽象

实际上，公司经营的B2C电商业务和电影票业务，在交易形态上有较大的区别，尤其体现在订单模块的设计上，订单的状态机、数据模型和财务账务处理模式完全不同。两者并没有太多的共性模块和功能，强行将两者合并后，最终只是表面上看起来实现了订单中台，但是其中的功能模块各自独立运转，完全没有实现抽象和复用。现在，公司管理者以为拥有了强大的订单中台，可以为快速开展新业务提供支持。很快，公司决定开展机票售卖业务，针对机票业务，有独立的C端、商品管理、促销管理。但是当产品经理和工程师开始期待订单中台的强大功能时，却遗憾地发现：订单中台无法给机票业务提供任何现成的功能复用能力，机票的订单模型和电商、电影票都不相同。

![image.png](./assets/1701873473923-image.png)

可见，在不同的业务模式下，订单中心并不一定适用于中台化建设，设计人员要有足够的思辨能力，判断产品形态上是否值得抽象下沉、是否能够提供复用能力。然而，这也是软件工程设计中非常难的部分。任何软件系统的设计都基于归纳法，而非演绎法，即软件设计人员总是通过对现有世界和业务的总结提炼，**而无法通过推测演绎完成软件设计。设计人员无法对业务的未来做出预测，只能基于有限的经验，尽量保证设计的灵活性和正确性。**

理解这一点非常重要，这会让你在软件设计、产品设计时心存敬畏，不会因一味地追求短期无法论证的结论而产生严重的过度设计。在实践中，对于基于抽象复用的平台建设，有以下几条建议。(1)对于明显具备共性的模块，尽早抽象。在B端产品的体系化设计中，很多形态的产品是具备明显共性的，我们可以尽早地进行抽象设计，这样在系统架构建设的早期就能做出正确的设计方案，而且并不会过多地增加研发工作量，相反会让未来的系统扩展更加轻松。例如，业务系统中的统一权限管理系统、单点登录系统、组织架构系统、公告系统、短信系统等，都应该尽早完成抽象建设。(2)对于共性不确定的模块，事后抽象。对于统一客户视图、订单中心、商品系统等软件模块，很难判断在多业务线场景下是否能够完全复用。如果对于是否进行抽象拿不准主意，那么完全可以先不做，等业务渐渐明确后，有足够的信息做出充分的分析和判断时，再决定是否合并抽象设计。

## 02 逻辑思维

2.2.1 概念要明确且清晰对概念的明晰和定义是我们设计过程中的重要内容。在一个领域内，如果一个系统的核心概念的定义出现了问题，可能会给上层的业务带来毁灭性的打击。此前我们在做社区团购业务的时候，由于系统是从盒马交接过来的，而在之前的系统中并没对商品、货品这两个重要概念进行区分，导致后续出现了领域边界不清、团队职责不清、系统修改困难等一系列问题。例如，我负责的商品系统对外会被供应链、仓库物流消费使用。作为商业的基本要素，商品被外部系统依赖本来也是正常的，只是原来的系统并没有清晰地明确商品和货品的概念，导致商品系统在承载商品管理职责的同时，还承载了货品的职责。管理的是商品，发布的是商品，采购的是商品，销售的是商品，仓内扫码作业还是商品。这种不区分上下文地使用“商品”这个概念，导致商品就像洪水一样以一种模糊的方式泛滥到各个系统中。

![image.png](./assets/1701950352143-image.png)

![image.png](./assets/1701950362253-image.png)![image.png](./assets/1701950372840-image.png)

2.4 逻辑三要素之推理前面提到，逻辑就是关系。

所谓推理，就是研究语句、判断、命题之间相互关系的学问。逻辑推理可以分为演绎推理(Deductive Inference)、归纳推理(Inductive Inference)和溯因推理(Abductive Inference)。

这也是为什么有很多哲学家认为归纳法虽然可以得到新知识，但是因为不能穷举，所以永远也得不到真理。然而，演绎法虽然可以保真，但因为结论蕴含在大前提中，又不能产出新知识，因此如果最后推导出有真理存在，那么真理只能是先验的（先于我们的感觉经验，先天存在于我们的意识之中）。然而科学知识都是来自科学归纳法的，所以真正的科学都是可以被证伪的，即当一种科学理论与最新的发现发生矛盾的时候，就需要一种新的理论来代替它。爱因斯坦的相对论虽然在牛顿力学的基础上迈出了一大步，但还是受到了量子力学的挑战，因此我们还需要一个能够解释所有力学现象的统一场论。这也是爱因斯坦终其一生都没有完成的工作，只能期待另一个“爱因斯坦”来完成了。

实际上，归纳和演绎并不是割裂的，而是彼此联系的，主要有以下两个原因。(1)为了提高归纳推理的可靠程度，需要运用已有的理论知识对归纳推理的个别性前提进行分析，把握其中的因果性、必然性，这就要用到演绎推理。(2)归纳推理依靠演绎推理来验证自己的结论。同样，演绎推理要以一般性知识为前提，这通常要依赖归纳推理来提供一般性知识。这一点在软件工程的建模工作中得到了充分的体现，建模是一个归纳工作，我们通过抽象问题域里具有共同特性的类来建立模型。为了验证模型的有效性，我们会使用演绎的方法去推演不同的业务场景，看看模型是否能满足业务的需要。这样的工作往往不是一次成型的，而是交替往复，最终才能得到一个相对合理的模型。

比如，我们收到系统异常报警后去查看系统日志，发现是一个依赖服务报了超时(Timeout)错误。我们的第一反应是：是不是网络出现了问题（假设）？接下来开始ping依赖服务的IP，发现网络没问题（求证）。于是我们提出了新的假设：是不是依赖服务内部出现了什么问题？接下来开始排查依赖服务的日志，发现是因为一个数据库操作过于频繁，导致响应时间超时。

可是这部分的代码很长时间没有修改了，为什么偏偏今天出现问题呢？

通过进一步排查，我们发现是缓存服务器出现了问题，导致本来调用缓存的操作全部被打到了数据库上。那么为什么缓存服务器会宕机呢？

通过进一步追查，发现是最近使用缓存的人比较多，内存空间不足导致了宕机。至此，我们才算真正找到了问题的根因(Root Cause)。

![image.png](./assets/1701951114155-image.png)

### 逻辑谬误

这些谬误包括偷换概念、错误假设、以偏概全、转移话题、人身攻击、以势压人、以众压人、循环论证、不适当地诉诸权威、不适当地诉诸情感、窃取论题、得寸进尺，等等。更多关于逻辑谬误的知识，推荐大家去看看《学会提问》这本书，接下来我会挑选几个常见的逻辑谬误进行简单介绍。

再比如，在面对烂系统时，阿里巴巴内部经常有一个说辞叫“野蛮生长”，言外之意是业务发展很快，技术来不及优化，只能草率支撑。这其中就隐含着一个前提假设——时间有限，系统就会烂。然而这个前提假设在逻辑上是不严密的，有没有可能在同等的时间下做到“既快又好”呢？我想，随着技术能力水平的提升，是有可能做到的。每个人的背景和身份不一样，代表的利益不一样，所以在话语中经常带有自己的价值倾向，只有把这些隐含的假设暴露出来，我们才能进行正确的判断。

以偏概全是使用归纳法时常见的谬误，即使用过小的样本量或者不具代表性的样本，归纳得到一个错误的结论。比如，用某一张偏方治好了某个人的某种疾病，**如果据此得出“这张偏方具有治疗该疾病的作用”，那就错了。现代临床医学研究总是强调大样本、多中心、随机、双盲和对照试验，目的就是避免在运用归纳法时陷入以偏概全的谬误。**

### 滑坡谬误和深度思考

逻辑链有相似之处，都是因果逻辑链条的延伸。然而它们也有本质的不同，深度思考的逻辑链是逻辑严密的推导，而滑坡谬误的逻辑链是逻辑关系不严密的放大。这种放大或出于焦虑，或出于无知，但肯定不是严密的逻辑推导，否则它就不叫谬误，而应该是深度思考了。比如，一位母亲告诫她年轻的女儿：“亲吻自然没有什么，但是想想亲吻能带来什么，接下来又会发生什么。只有你弄清楚这些，你才会避免成为一个可怜孩子的妈妈，否则你年轻的生命就永远地毁了！”焦虑的滑坡谬误操纵者忘了一点，那就是许多行走在滑坡上的人都很小心，并不会跌倒。如今的教育“内卷”实际上也是一种滑坡谬误，很多家长不想让小孩输在起跑线上，认为不上好幼儿园就上不了好小学，不上好小学就上不了好中学，不上好中学就上不了好大学，上不了好大学这辈子就没有希望了。

### 逻辑需要理性，但感性同样重要，不要“得理不饶人”，把自己变成了“杠精”。

## 03 结构化思维

我们把这种各要素的组织形式（要素之间的关系）称为结构。系统的性质是由结构决定的。要素的内容是不稳定的，可能随时会被替换。就像忒休斯之船，虽然船的木板被换掉了，但只要船的结构没有变，其仍然是忒休斯之船。中国长达两千余年的封建历史也是一样，皇帝（要素）一个接一个地换，但是本质上，其背后的皇权制度没有变，旧社会的结构没有变，所以皇帝的更替并没有改变封建社会的本质。我们通常说的“结构性问题”是指那些底层的、难以改变的根本性问题。经济上的结构性问题就是作为经济这个系统的结构的经济制度——分配制度和所有制等出现了问题。

我们把这种各要素的组织形式（要素之间的关系）称为结构。系统的性质是由结构决定的。要素的内容是不稳定的，可能随时会被替换。就像忒休斯之船，虽然船的木板被换掉了，但只要船的结构没有变，其仍然是忒休斯之船。中国长达两千余年的封建历史也是一样，皇帝（要素）一个接一个地换，但是本质上，其背后的皇权制度没有变，旧社会的结构没有变，所以皇帝的更替并没有改变封建社会的本质。我们通常说的“结构性问题”是指那些底层的、难以改变的根本性问题。经济上的结构性问题就是作为经济这个系统的结构的经济制度——分配制度和所有制等出现了问题。

![image.png](./assets/1702031402166-image.png)

综上，结构化思维是一种以逻辑（事物内在规律）为基础，从无序到有序搭建结构的思维过程，如图3-2所示。其目的是降低复杂度和认知成本，因为大脑更喜欢概念少、有规律的信息

金字塔结构说到结构化思维，就不得不提到结构化思维的“圣经”——芭芭拉·明托的《金字塔原理》。这本书在业界也有很好的口碑，我反复读过多遍。美团的王兴曾说，仔细认真读完这本书，是员工在美团获得成功的基本功。它是美团“四大名著”之首，也是美团能力跃迁、职级晋升的官方推荐必读书籍。

知识分类： **社会  经济 政治  文化  科学**

按照MECE法则去分类

从上往下分类

按照

归纳和演绎 在分析的时候是相辅相成的

2W1H是构建结构时最常用，也是最有用的框架之一。因为它涉及一个问题最核心的3个要素，即“是什么”“为什么”和“怎么做”。有了2W1H这个思考框架，

我为“**如何写好技术文章**”搭建了自上而下的结构（如图3-15所示），接下来写出这篇软技能文章，也就不是什么难事了。

(1)为什么写文章：

1）写文章是费曼学习法；2）写文章可以增加影响力。

(2)什么是好文章：1）内容有价值；2）结构要清晰。

(3)如何写好文章：1）选择好内容；2）搭建清晰的结构；3）刻意练习；4）迭代优化。

![image.png](./assets/1702032597547-image.png)

2W1H实际上是对5W1H的简化和提炼，如果需要更加全面的思考，那么要尽量满足MECE原则，此时5W2H（Why、Who、When、Where、What、How和How much）可能是更好的选择。此外，我们还可以用“疑问解答”的方式自上而下地搭建结构。这样做的好处是，一方面可以通过设置悬念来吸引听众的注意力；另一方面，这种不断问“为什么”的方式也在帮助我们更加深入地理解问题，让论证更有说服力。假设你要给大家分享“猪应当被当作宠物来养”这个话题，大部分听众会很疑惑：“为什么猪可以当宠物呢？”你接着说“猪很漂亮，所以可以当宠物”。这回答了前面的疑问，却又引发了大家新的疑问：“猪怎么能漂亮呢？”，然后你说“因为猪很肥”。大家的疑问更多了：“肥为什么还漂亮呢？”这样一步一步往下走，用先抛结论的倒序方式紧扣着听众的好奇心，如图3-16所示。这种提出疑问、回答疑问的悬念方式是非常有吸引力的，同时，因为你对对方关心的问题逐一进行了解答，说服力自然也会比较高

### 坏味道

商品是电商系统中最重要、最复杂的要素之一。在发布商品的时候，我们需要组装商品(offer)的各种参数。offer需要的信息特别多，导致组装offer的代码篇幅也特别长。随着时间的推移，还不断有新的信息被添加到这个方法中。如果把代码类比成文章，那么这是一篇没有章节、没有段落的文章，可想而知其可读性和可维护性有多糟糕。

![image.png](./assets/1702032771286-image.png)按照同样的业务逻辑，对比两种不同的实现方式，不难看出结构在其中起到了重要的作用。所以，写出优雅的代码也许不在于运用多么高深的技法，而在于是否能静下心来把结构梳理清楚。

### 各种思维模型

对比两个会议通知，不难发现，5W2H的结构能让表达更有条理、更清晰。幸运的是，针对不同的问题场景，前人已经总结了很多解决特定问题的结构框架，具体如下。我们不用绞尽脑汁地去寻找分析问题的角度，可以拿来即用。(1)制定市场营销策略的“4P”模型：即产品策略(Product Strategy)、价格策略(Price Strategy)、渠道策略(Place Strategy)、促销策略(Promotion Strategy)。(2)思考组织战略的“7S”模型：即经营策略(Strategy)、组织结构(Structure)、运营系统(System)、经营风格(Style)、职员(Staff)、组织技能(Skill)和共享价值观(Shared Value)。(3)分析竞争力的SWOT模型：SWOT分析代表分析企业优势(Strengths)、劣势(Weakness)、机会(Opportunity)和威胁(Threats)。(4)制定目标的SMART模型：即制定目标要满足确定性(Specific)、可度量性(Measurable)、可实现性(Attainable)、相关性(Relevant)和时效性(Time-

## 04 批判性思维

来看一个例子，小王去一家公司面试，被拒绝了。他没有拿到心仪的offer，很伤心，也很失落。他开始想是什么原因呢？他想到的第一个原因是自己没有熟人的内推，这时他想到他的另一位同学因为有内推的机会，所以拿到了一个很好的offer，他开始生气，抱怨自己没有同样的运气。另外，他又想到了一个原因，他觉得今天的面试官对自己有偏见，因为他进门的时候，面试官都没有看他一眼，而且面试官是一位女士，他想到了这几次面试失败，面试官都是女性，而且在他面试结束时都没有送他出门。他越想越不服气，甚至还有点愤怒。你认为这里出现了什么问题呢？小王的思维过程存在哪些缺陷呢？小王用到了多种思维方式，比如类比推理，他类比了他的另一位同学；他也用到了归纳推理，对一些小细节进行归纳，比如面试官是女性，面试官没有正眼看他，等等。综上，他归纳了面试失败的一些原因，但问题在哪里呢？他并没有达到批判性思维的层次。批判性思维要经历3个过程：体验、解释和分析。

来看一个例子，小王去一家公司面试，被拒绝了。他没有拿到心仪的offer，很伤心，也很失落。他开始想是什么原因呢？他想到的第一个原因是自己没有熟人的内推，这时他想到他的另一位同学因为有内推的机会，所以拿到了一个很好的offer，他开始生气，抱怨自己没有同样的运气。另外，他又想到了一个原因，他觉得今天的面试官对自己有偏见，因为他进门的时候，面试官都没有看他一眼，而且面试官是一位女士，他想到了这几次面试失败，面试官都是女性，而且在他面试结束时都没有送他出门。他越想越不服气，甚至还有点愤怒。你认为这里出现了什么问题呢？小王的思维过程存在哪些缺陷呢？小王用到了多种思维方式，比如类比推理，他类比了他的另一位同学；他也用到了归纳推理，对一些小细节进行归纳，比如面试官是女性，面试官没有正眼看他，等等。综上，他归纳了面试失败的一些原因，但问题在哪里呢？他并没有达到批判性思维的层次。批判性思维要经历3个过程：体验、解释和分析。

来看一个例子，小王去一家公司面试，被拒绝了。他没有拿到心仪的offer，很伤心，也很失落。他开始想是什么原因呢？他想到的第一个原因是自己没有熟人的内推，这时他想到他的另一位同学因为有内推的机会，所以拿到了一个很好的offer，他开始生气，抱怨自己没有同样的运气。另外，他又想到了一个原因，他觉得今天的面试官对自己有偏见，因为他进门的时候，面试官都没有看他一眼，而且面试官是一位女士，他想到了这几次面试失败，面试官都是女性，而且在他面试结束时都没有送他出门。他越想越不服气，甚至还有点愤怒。你认为这里出现了什么问题呢？小王的思维过程存在哪些缺陷呢？小王用到了多种思维方式，比如类比推理，他类比了他的另一位同学；他也用到了归纳推理，对一些小细节进行归纳，比如面试官是女性，面试官没有正眼看他，等等。综上，他归纳了面试失败的一些原因，但问题在哪里呢？他并没有达到批判性思维的层次。批判性思维要经历3个过程：体验、解释和分析。

![image.png](./assets/1702092688651-image.png)![image.png](./assets/1702092700618-image.png)

![image.png](./assets/1702092724218-image.png)

1.协作成本研发≠写代码，实际上我们大部分时间不是在写代码，而是在沟通协调，况且与人打交道要比与机器打交道麻烦得多。这也是《人月神话》一书中说“加人只会让项目更糟糕”的原因，因为额外增加了更多的协作成本。除了组织协作成本倍增，耦合带来的工程协作成本也很高。试想一下：如果几百名研发人员在同一个代码库上修改代码并部署，会是怎样的体验？以下是一位同事的真实反馈：“业务中台在外面宣传的是业务方7×24小时想发就发，实际远远做不到，很多限制，效率很低，体验过才知道。”

2.认知成本就阿里巴巴的业务中台体系来说，不可谓不复杂，其中有大量的新概念——业务身份、活动(Activity)、领域服务(Domain Service)、领域能力(Ability)、扩展点(ExtensionPoint)，扩展实现(Extension)、奥创、Lattice、业务容器，等等。这些概念显著增加了开发者的认知负荷，让系统变得异常复杂。

3.稳定性成本现在的业务中台很精巧，同时也很脆弱。它与所有的大设计(Big design up front)犯了同一个错误，即忽视了那些“对未知的未知(Unknow unknows)”。业务的灵活性和差异性导致我们很难提前抽象，因为抽象在归纳之后，可是新的业务需求还没出现。理想的情况是我们能预见所有的业务变化，提前做抽象，预留所有的业务扩展点，这样针对不同的业务只需要在扩展点中定制就好了。但没人能预见未来，这样就难免要改动平台代码，比如加一个扩展点。由于平台代码是被所有业务共享的，这就给稳定性带来了极大的隐患。比如，A业务改动了平台代码，然而B业务什么也没做就出了故障。

### 4.2.3 解决中台的困境

为了解决上述业务中台碰到的问题，我认为可以尝试做以下工作。(1)把业务能力做薄。做薄是为了解耦，业务最懂自己，因此不要尝试去“control”它们。中台可以更多地关注与“业务无关”的能力建设，比如稳定性、性能、监控、运维工具等非功能属性。(2)把中台能力做强。除了非功能属性，中台还可以通过建设丰富的业务解决方案库、业务组件库等工具，赋能业务快速发展，用enable代替control。(3)把系统结构做简单。这一点很好理解，因为复杂是万恶之源。

实际上，重复(Duplication)也是一种重用(Reuse)。这样做可能会导致不同的业务代码之间出现一些代码冗余（实际上，出于快速发展和稳定性的考虑，有些业务已经在采用重复代码的方式，比如淘特、APOS）。然而，在稳定性、可理解性、可维护性、工程效率的综合权衡之下，这点代码冗余会显得微不足道。

正如Neal Ford在《软件架构》一书中提到，当一个架构师设计一个系统的时候，他如果选择重用，那么同时也选择了耦合。因为重用不管是通过组合(Composition)还是继承(Inheritance)实现，都会引入耦合。然而，如果你不想耦合，可以采用重复代替重用。[插图]也就是说，架构需要在重用高耦合和重复低耦合之间做一个权衡，所以代码重复(Ctrl+C/Ctrl+V)并不总是差的，而是一种设计选择。

### 4.3 批判架构师

Martin Fowler在他的一篇IEEE论文“Who Needs an Architect？”（见链接4-1[插图]）中提到，能使团队更加敏捷的架构师比只做决定的架构师要更有价值，因为只做决定的架构师会成为团队的瓶颈(bottleneck)。显然，一个架构师的价值和他做的决定是成反比的。实际上，在这篇文章中，Martin甚至不认为架构师(Architect)这个名词是合适的，他认为更合适的叫法应该是向导(Guide)，即一个更有经验的人带领团队走出复杂的迷雾。

### 4.3.1 尴尬的架构师

在进入阿里巴巴工作之前，我就职于eBay的支付部门。当时有一位架构师，所有的设计和方案都需要获得他的审批才能通过，结果他成了整个团队的瓶颈，很多事情都堆积在他那里。工程师很难受，光是给他介绍和讨论业务及系统设计就需要花费大量的时间（因为时差原因，经常要讨论一周才有定论）；他也不容易，要理解每个系统的结构和业务细节也是很累的。

### 4.4 批判技术管理者

在某些业务技术团队中，有一个不好的趋势就是团队越来越业务化，越来越没有技术味道。每个人都在谈业务，技术大会上在谈业务、周会上在聊业务、周报里写的是业务项目……唯独少被谈及的是技术本身。这里并不是说业务不重要，而是说理解业务和把控业务需求是技术人员的基本要求，但并不是全部。对技术团队来说，技术味道的缺失是非常可惜的，不利于技术人员的成长和发展。很难想象一个没有技术追求的团队能开发出一个健壮、可维护性好、可扩展性好的系统。业务代码的堆砌，从短期看也许较快实现了业务需求，但是从长远来看，这种烂系统的增加会严重阻碍业务的发展，形成一个个的“屎山(shit mountain)”系统，而工程师被裹挟在业务需求和烂系统之间心力交瘁。

![image.png](./assets/1702093294051-image.png)

![image.png](./assets/1702093614936-image.png)

在软件领域，很多问题都要批判、辩证地来看。比如，敏捷开发就一定比瀑布式好吗？微服务就一定比单体好吗？

## 05 维度思维

在第3章中，我们知道结构化思维可以有效地帮助我们分析问题，并以清晰的、有逻辑的、易于理解的方式表达出来。但是有一个问题，即结构化思维通常只适用于单向维度的问题分解。

比如，**业务流程的结构化分解、文章结构的结构化分解，以及代码结构的结构化分解**，都是在单一维度上对问题域进行分析、拆解和综合。

在第3章中，我们知道结构化思维可以有效地帮助我们分析问题，并以清晰的、有逻辑的、易于理解的方式表达出来。但是有一个问题，即结构化思维通常只适用于单向维度的问题分解。比如，业务流程的结构化分解、文章结构的结构化分解，以及代码结构的结构化分解，都是在单一维度上对问题域进行分析、拆解和综合。

![image.png](./assets/1702175822357-image.png)

关于“点—线—面—体”的思考，梁宁在她的产品课中也有非常精彩的阐述：

当你想做一个产品的时候，入手只能是一个点。但需要想清楚，它附着在哪个面上？这个面在和谁竞争，它能如何展开？这个面在哪个经济体上？这个经济体是在快速崛起，还是在沉沦？悲惨的人生，就是在一个常态的面上，做一个勤奋的点。更悲惨的人生，就是在一个看上去常态的面上，做一个勤奋的点，你每天都在想着未来，但其实这个面正在下沉。最悲惨的人生，就是在一个看上去常态的面上，做一个勤奋的点，其实这个面附着的经济体正在下沉。如果一个人一生只能收到点状努力的即时收益，从来没有享受过一次线性周期的成果回报，这就叫穷人勤奋的一生。

由此可见，思考的维度决定了我们思考的深度和全面性。当思考落在一个“点”上的时候，往往会出现偏差。比如，我们从小被教育浪费可耻，所以即使吃饱了，也要把盘子里面的饭吃完。殊不知，如果把时间线拉长，长期这样做，对自己的健康并没有什么好处，还可能因为发胖而耗费更多的资源去减肥。写代码也是一样的。很多人认为业务代码只要能实现业务功能，丑一点、难看一点又有什么关系呢？这也是一种“点”状思维，把时间线拉长，后期你可能需要付出更多的精力为烂系统买单。只是这个买单的人除了你，还有可能是接手你这个系统的倒霉蛋。总而言之，多维度思考是思考的高级阶段，是体系化思考的必备，是解决复杂问题的一把利器。但我们的大脑天生是懒惰的，不善于从多个维度去思考问题，因此我们需要借助一些工具来辅助进行多维度思考。如果只能选一个思维工具，那**么这个工具应该非“矩阵分析”莫属。**

这3个维度上的差异组合起来，有2×3×2=12种之多。

这是为什么在老代码中，到处都是“if（组合品）…，if（赠品）…，if（实仓）…”之类的代码。为了消除这些令人讨厌的if else，通常有以下两种方式。(1)多态扩展（重用）：利用面向对象的多态特性，实现代码的复用和扩展。(2)代码分离（重复）：对不同的场景使用不同的流程代码实现。

### 5.3.3 矩阵分析

细心的读者可能已经发现了，在上面的案例中，普通商品和组合商品的业务流程基本是一样的。如果采用两套编排代码，有点冗余，这种重复将不利于后期的代码维护，出现散弹式修改（一个业务逻辑要修改多处）的问题。一种极端情况是，假如普通商品和组合商品只有checkSellable()不一样，其他都一样，那么毫无疑问，使用有多态（继承关系）的CombineItem和Item来处理差异会更合适。而赠品上架的情况恰恰相反，它和其他商品的上架流程差异很大，反而不适合与它们合用一套流程代码，这样反而会增加他人的理解难度，还不如单独发起一个流程来得清晰。那么问题来了，**我们什么时候要用多态来处理差异，什么时候要用代码分离来处理差异呢？**

### 5.3.4 殊途同归

我曾一直以为矩阵分析是我的原创，至少在软件工程中的应用是原创的，还一度非常开心。直到有一天，我看到了Alan Shalloway写的《设计模式解析》(Design Patterns Explained)，其中第16章专门讲了“分析矩阵”。他对分析矩阵的起源有这样的描述：虽然这里所讲述的例子非常简单，但我是为了解决一个极大的问题而发明分析矩阵的。在那个问题中，有成百上千种情况、50多种变化。我发现自己当时甚至无法与项目的分析师交谈，因为信息实在是太多了。认识到没有老路可走之后，我清楚自己需要提出一种组织海量数据的新方式。

![image.png](./assets/1702177121082-image.png)

### 波士顿矩阵

![image.png](./assets/1702177702589-image.png)

通过上面的案例，我们可以将矩阵分析过程归纳为如下3个步骤。

• 第一步：发现问题的关键要素。比如对于产品分类来说，销售增长率和市场占有率是关键要素；对于员工绩效来说，业绩和价值观是关键要素。

• 第二步：构建矩阵。矩阵的维度取决于要素变量的数量，矩阵的行数取决于变量值的多少。

• 第三步：呈现矩阵。对于两个变量，每个变量的取值小于等于3的情况，我们可以使用四象限或九宫格呈现。对于多维多值的情况，只能使用表格了。

![image.png](./assets/1702177802100-image.png)

![image.png](./assets/1702178409256-image.png)

![image.png](./assets/1702178696491-image.png)

![image.png](./assets/1702178915635-image.png)

## 06 分类思维

所谓分类，就是依据一定的标准对给定的事物划分组别。别看定义简单，但在我们的工作和生活中，分类思维有着重要的意义。正如产品大师张小龙说过的一句非常经典的话——“设计就是分类”。对事情的分类，本身已经完成了设计的工作。

所谓分类，就是依据一定的标准对给定的事物划分组别。别看定义简单，但在我们的工作和生活中，分类思维有着重要的意义。正如产品大师张小龙说过的一句非常经典的话——“设计就是分类”。对事情的分类，本身已经完成了设计的工作。

假设一个应用程序中有几十万行代码。如果使用C语言，平均每个子程序编写50～100行代码，那么子程序就有几千到几万个；如果使用OOP，平均在每个类中汇总10个子程序，那么类的总数就比子程序的总数减少1个数量级，大概是几百到几千个，如图6-2所示。当然，这个数量依然很庞大，为了进一步汇总，我们还可以使用“包”“组件”“模块”功能做进一步聚合

### 6.4 没有“完美”分类

分类从来就不是一件简单的事情，即使是可枚举属性的经典分类，我们有时也会遇到困难。比如性别分类，在某些特殊场景下，仅仅是男性和女性也还是不够的。这一点在生物学分类上体现得尤为明显。作为一门学科，生物分类学至今也没有弄清楚对生物种类的明确划分。

对Module和Component的定义相对比较模糊，没有一个统一的标准。这些分歧从Stack Overflow中数十篇询问关于这些概念差异的提问，以及五花八门的回答中就可见一斑。在Stack Overflow的一篇贴子中，可以看到这样的回答：“这两个术语很相似，只是Module的概念通常比Component要大一些。”然而在另一篇帖子中，却有着截然不同的答案：“没有一个标准来衡量这两个概念哪个更大，一个组件可以包含多个模块，一个模块也可以包含多个组件。”相比较而言，我更赞同AngularJS设计文档中关于Module和Component的定义：“Module由一组Components组成，Component可以使用其他的Components，多个Module组成了一个Application。”根据AngularJS中的定义，Module是比Component更大的概念，如图6-3所示。比如在Maven中，Module是组成Application的第一级层次，而Component的粒度一般比Module小，多个Component会组成一个Module。

![image.png](./assets/1702270730875-image.png)

![image.png](./assets/1702270772026-image.png)

## 07 分治思维

7.2 分布式系统最宏大的分治非大型分布式系统莫属。面对动辄几亿用户、几十万的并发量、上TB(Tera Byte, 1TB=1024GB)的数据，传统的基于IOE（IBM的小型机、Oracle的数据库、EMC的存储）的纵向系统架构会遭遇瓶颈，急需一套“小而美”、可容错、分布式的水平扩展解决方案。随着各大互联网公司“去IOE”动作的完成，以及容器化、微服务、云原生等技术的日趋完善，基于分治思想的分布式系统架构已成为大型互联网公司的标配。

分布式之所以强大，是因为它可以支撑“接近无限”的业务扩展诉求。在《架构真经》的第2章“分而治之”中，作者提出了AKF扩展立方[插图]的概念，如图7-5所示。按照x、y、z这3个维度进行设计，这是一个可以支撑“接近无限扩展”的分布式系统扩展解决方案。

![image.png](./assets/1702270845832-image.png)

7.4 解决问题的黄金三步传统的分而治之是把一个大问题分解为多个小问题，各个击破。但是从上面的分治算法中我们可以看到，在分治之后，还有一个合并的过程。之所以有合并的步骤，是因为我们需要把分解之后的元素整合成一个新的有序序列，从而达到排序的目的。

因此，更泛化地来看待这个问题，我将分治并演化为一个通用的解决问题的框架——黄金三步。即我们可以用以下3个步骤来解决一些需要分治并的问题，如图7-9所示。• 第一步：定义问题，弄清楚我们要解决的问题究竟是什么。• 第二步：分解问题，把一个大问题拆解成多个子问题。• 第三步：合并问题，对拆解后的子问题，我们有必要再进行一次合并归类。![image.png](./assets/1702270893731-image.png)

### 例子：

流式计算

管道

责任链模式

分布式系统

### 回顾

• 解决复杂问题要分治，计算机涉及的问题都比较复杂，需要分而治之来解决。• 软件中存在大量的分治思想，比如管道模式、分层架构、分布式架构等，无不体现了分治的强大。• “分治并”是分治的进阶，有些问题除了分治，还需要整合、合并。• “分治并”本质上对应的是定义问题、分析问题、解决问题的通用步骤。• 很多问题在解决过程中都显性或隐性地使用到了“分治并”，比如分治算法、流式计算、分布式数据库系统。

## 08 简单思维

《UNIX编程艺术》的作者在书中提到，所有的UNIX哲学浓缩为一条铁律，那就是各地编程大师们奉为圭臬的“KISS(Keep It Simple and Stupid)原则”。在2021年的微信产品公开课上，张小龙说，简单是一个非常高的目标，不是一个简单的目标。他认为，简单能代替美观、合理、优雅，可能很多人并不认同，但在他看来，简单是很美的、最简单的，也可能是最好的。十年来，微信增加了很多功能，但让他庆幸的是，现在的微信还几乎和十年前的微信一样简单。虽然比十年前多了非常多功能，但这些功能用的已经是最简单的办法了，所以增加的复杂度会小。简单才会好用，特别是一个产品有十亿人在用的时候。

正如人们所说，把一件事情搞复杂是一件简单的事，但要把一件复杂的事变简单，这是一件复杂的事。

8.1 简化是逆向做功简化本质上是一个熵减活动。所有的事物都在缓慢熵增，就像凯文·凯利在《必然》一书中提到，世间万物都需要额外的能量和秩序来维持自身，无一例外。这就是著名的热力学第二定律，即所有的事物都在缓慢地分崩离析。而熵减就是逆向做功，即通过更多的努力让混乱的系统重新归于秩序。对于技术人员来说，我们可以通过以下手段来实现系统的简化。

对于技术人员来说，我们可以通过以下手段来实现系统的简化。8.1.1 压缩、隐藏与赋予在《简单法则：设计、技术、商务、生活的完美融合》一书中，

作者提到了一个SHE简化法则——**S是Shrink（压缩），H是Hide（隐藏），E是Embody（赋予）**。对于小的东西，人们对它的期望值会比较低，如果它同时功能强大到超出人们的预期，那么自然可以带给人惊喜。科技本身就是在做压缩，比如，计算机在诞生之初是重达27.2吨、占地167平方米的庞然大物，现在芯片可以压缩到小拇指指甲盖的十分之一大小。艺术借助轻巧单薄的形象来唤起人们的情感，对抗复杂本质的力量是脆弱，因为它可以引发怜爱，怜爱让人无法抗拒。

面向对象设计中的封装也是同样的道理。如图8-1所示，好的模块设计应该是像左边那样深且厚的，因为更少的接口意味着更低的理解成本和复杂度，更厚的深度可以提供更多的功能；而那些浅而薄的模块，看起来不仅复杂，而且用处不大。![image.png](./assets/1702388356091-image.png)

举一个例子  传参的数量   能压缩为一个字符串传过来是最好的

在函数内部进行解析

就像在组件间传递数据一样  可以压缩再传递

![image.png](./assets/1702388429805-image.png)

好的产品并不是要做到大而全，而是有节制。给用户太多的选择，有时还不如不给选择，因为用户自己也不知道自己想要什么。例如，即时通讯(Instant Message,IM)工具QQ提供了非常丰富的文本编辑功能，字体类型、大小、颜色和样式等选择应有尽有。然而，IM的本质是传递信息，这些“锦上添花”的功能并不是核心。因此，微信虽然并没有给用户提供这些选项，但是并不妨碍用户的使用，反而成就了一个更伟大的产品。

![image.png](./assets/1702388535516-image.png)

1543年，波兰天文学家哥白尼在临终时发表了一部具有历史意义的著作——《天体运行论》。这个理论体系提出了一个明确的观点：太阳是宇宙的中心，一切行星都在围绕太阳旋转。该理论认为，地球也是行星之一，它一方面像陀螺一样自转，另一方面又和其他行星一样围绕太阳转动。哥白尼的计算不仅结构严谨，而且计算简单，与已经加到八十余个本轮的地心说相比，哥白尼的计算与实际观测资料能实现更好的吻合。因此，地心说最终被日心说取代。

# 第二部分　专业思维能力

这部分主要结合软件行业的特点介绍其特有的专业思维能力。比如，契约思维、模型思维、工具化思维、量化思维、数据思维、产品思维等都是在软件领域中非常重要且经常会用到的思维能力

## 10 解耦思维

人生最难熬的痛苦，就是你跟本该远离的东西纠缠在了一起。

第4章提到了业务中台困境的根本原因是“深度单体耦合”。耦合带来了业务前台和业务中台高昂的协作和认知成本，抵消了复用节省的时间成本，总体上反而造成了研发效率的下降。由此可见，软件设计的一大目标就是“解耦”。模块之间的联系越少，耦合越小，系统就越灵活，可修改性越好。在一个设计良好的系统中，数据库代码和用户界面应该是正交的。这样我们可以改动界面，而不影响数据库；在更换数据库时，可以不用改动界面。

团队之间的关系也一样，要尽量做到正交。假如在一个研发团队中，成员之间边界不清、职责不清，工作中有很多重叠、踩脚的现象，那么一旦出现问题，大家互相之间“踢皮球”，这肯定不是一个高效的研发团队。

### 10.1 耦合与解耦

耦合的“耦”，在中国古代是指两人并肩而耕，也就是两个人在一起合作使用农具耕地，这是上古农耕时代对农业生产的写实描述，是中古时代以前古中国的田园生活写照，

从这个意义上来说，解耦并不会完全解开耦合，而是使用一些方法降低耦合的程度。在软件世界中，**解耦有两种主要方式——依赖倒置解耦和中间层映射解耦。**

不太理解

### 10.2 依赖倒置解耦

依赖倒置是SOLID设计原则中的“D”，全称是Dependence Inversion Principle，即依赖倒置原则，其定义如下。

(1)上层模块不应该依赖底层模块，它们都应该依赖于抽象。(High level modules should not depend upon low level modules.Both should depend upon abstractions.)

(2)抽象不应该依赖于细节，细节应该依赖于抽象。(Abstractions should not depend upon details.Details should depend upon abstractions.)

根据定义，我们知道依赖倒置实际上倒置的是依赖方向。如图10-1所示，有两个模块A和B，本来A是直接依赖B的，依赖方向是A→B，通过增加一个抽象C，然后让模块B去实现这个抽象，从而反转了依赖的方向，变成B→A，这就是依赖倒置。

![image.png](./assets/1702466818737-image.png)

所谓的解决方案中立，是指我们在思考解决方案的时候，不要一开始就陷入功能细节中，要尽量抽象一点，保留更多的可能性，为创新留下空间。如果对于开酒瓶这个操作，你只能想到拔瓶塞，那么就会错失其他的可能性。如图10-3所示，开酒瓶更抽象、更泛化的表述方式应该是“移动瓶塞”，“移动”比“拔”更抽象，因为其力量既可以来自拉力，也可以来自推力。

比如 输入 输出类

而不是输出到es  输出到redis 这种具体的  要抽象一点

![image.png](./assets/1702467153560-image.png)

### 10.2.3 应用与日志框架的解耦

前文提到的耦合比较显性化，基本在设计的时候就能感知到。然而还有一种耦合比较隐蔽，如果它不出现问题，我们根本不会意识到耦合性的存在。

比如对于日志框架的使用，如果我们使用Commons-Logging（通用日志），则直接依赖Commons-Logging；

如果使用Log4j，则直接依赖Log4j；

如果使用Logback，则直接依赖Logback。

倘若我们一直只使用一个日志框架，那么这个问题其实不会被暴露，然而一旦我们要切换日志框架，那么这种耦合性就会带来巨大的麻烦。因为不同日志框架的包名和API用法都不尽相同，其切换成本会非常高。

虽然SLF4J已经大大降低了迁移日志框架的潜在成本，但我仍然建议大家用MyLogger做一层防腐。假如有一天出现一个更好的日志框架，而它又没有遵守SLF4J的规范，那么如果我们强依赖SLF4J，同样会导致变更困难；而如果我们用的是自己的MyLogger，那么迁移工作将会非常简单，只要将slf4jLogger替换成新的Logger就好。

![image.png](./assets/1702467281812-image.png)


### 10.3 中间层映射解耦

“计算机中的任何问题，都可以通过加一层来解决”，这句话体现了中间层映射的设计理念。如图10-8所示，当A对B有依赖时，A不要直接依赖B，而是抽象一个中间层，让A依赖中间层，再由中间层映射到B，这样当B改变时，不用修改A，只需调整中间层的映射关系。

10.4 解耦的技术演化

我发现从某种意义上来说，应用技术的演化史也是一部解耦史。如图10-13所示，从面向对象的“原始社会”到面向资源的“云淡风轻”，技术的每一步发展都伴有解耦的烙印。

![image.png](./assets/1702467804552-image.png)

(1)原始社会在所有的编程形态中，当属自己创建对象(New Object)的耦合性最高了。就像未开化的原始社会，我需要一把斧头，没有人给我制造，只能靠自己用石头磨出来。(2)工业社会时代继续向前发展，开始进入工业社会。我需要一把斧头，这时不再需要自己生产，而是由工厂(Factory Pattern)统一生产。通过工厂，实现了对象和对象使用者之间的解耦。(3)共产主义社会工厂模式虽然实现了对象和对象使用者之间的解耦，但是使用者还是要感知Factory的存在，这种感知也是一种耦合。有没有一种办法把对Factory的耦合也去掉？就像共产主义社会一样，实现“按需分配”。

在这个背景下，以Spring为代表的依赖注入(Dependency Inversion, DI)技术产生了，使用BeanFactory框架，统一实现对象的初始化、依赖、生命周期的管理。应用程序不需要自己创建对象和Factory，其所依赖的对象都由框架进行“注入”，从而实现了进一步的解耦。(4)分布式时代——RPC在单个应用中，以Spring为代表的“共产主义社会”已经把解耦做到了极致。可是单体应用能够承载的复杂度和开发人数是有限的，对象解耦只是最基础的解耦方式。接下来，要解决的是“协作解耦”，即把一个大应用拆分成多个小应用，让每个小团队维护自己的小应用，实现并行开发，也就是我们说的“分布式应用”。分布式技术由来已久，Java在JDK1.2中就实现了远程方法调用(Remote Method Invocation, RMI)，包括在国内比较常用的由阿里巴巴开源的Dubbo，以及阿里巴巴内部使用的HSF(High-speed Service Framework)，它们都属于远程过程调用(Remote Procedure Call, RPC)技术的范畴。

## 11 契约思维

在软件工程中，契约思维有规范和标准两个方面的重要价值。(1)规范价值：一致性可以降低认知成本和复杂度，一个系统如果没有任何的规范约束，那么呈现出来的结果就是混乱。面对混乱，再优秀的程序员也会寸步难行。(2)标准价值：大规模社会分工协作离不开标准，如果螺丝钉没有标准，那么每个企业就不得不自己生产适合自己的螺丝钉。同样，如果浏览器没有标准，那么针对不同的浏览器的同一个功能，就要写多份不同的代码。所以我们说，“一流的企业定标准，二流的企业做品牌，三流的企业卖产品”

### 11.1 软件设计中的规范

作为一名程序员，你可能遇到过这样的情况：代码评估要两天，而修改代码只需要几分钟。这种局面主要是由系统的混乱无序造成的，因为缺少规范和约束，代码的复杂度随意滋长，导致维护困难。面对这样的代码，往往要花费很长时间去厘清代码结构和业务逻辑，而真正需要修改的点也许只是“一行代码”而已。

根据我的经验，我一般至少会在团队中落实**命名规范、异常处理规范、架构规范。**实践证明，这3个规范可以有效地帮助团队治理代码复杂度。

## 命名规范、

每个开发团队都应该有自己的命名规范，确保命名的一致性。对于核心的领域概念，应该有一个核心领域词汇表，确保这些领域词汇在代码中的表达是一致的。我曾经在一个商品项目中看到一个和库存相关的逻辑，在短短的一段代码中，就有3种不同的对库存的描述方式，分别是Stock、Inventory、Sellable Amout。这意味着对同一个领域概念，我需要理解3遍，这极大地增加了我的记忆负担和认知成本。然而，如果团队有一个命名规范——核心领域词汇表，加上团队成员的共同遵守和维护，其实上述问题是可以避免的。

![image.png](./assets/1702522850877-image.png)

这里需要注意，关于CRM中的私海和公海这两个术语并没有采用标准的英文翻译——territory，而是选择了一个典型的“chinglish”翻译——privateSea和publicSea，原因是后者更形象、更好理解，因此我们可以考虑放弃准确性来提升可理解性。再者，语言只是符号，共识即正确，只要团队达成一致的共识，是否是标准的英语也就没那么重要了。

![image.png](./assets/1702523315408-image.png)

* -Trace：程序流程记录日志，用于最细致的程序逻辑跟踪，面向开发/测试/实施人员，非常规使用
* 如：循环中记录程序的流程或状态、监测调度框架跟踪记录等
* -Debug：程序调试日志，用于详细跟踪程序的执行逻辑和状态信息，面向开发/测试/实施人员，常规使用(发布版本不能开启Debug及以下级别日志)
* 如：程序流程或逻辑跟踪、数据或状态跟踪、参数传递不合法反馈、监测资源抛出异常等
* -Info：信息类日志，用于直观展示系统运行信息，面向用户/客户/三方人员，常规使用
* 如：系统运行跟踪日志(用户登录/删除数据等重要操作)、重要模块调用、资源使用等
* -Warn：警告日志，用于程序运行抛出异常，但不影响功能使用，面向开发/测试/实施人员，常规使用
* 如：资源访问等不影响功能异常
* -Error：错误日志，用于程序运行出现错误，导致功能中断，面向系统所有人员，常规使用
* 如：资源使用错误、使用API程序无法处理等导致业务无法完成错误

总结：开发中通常使用的是Debug/Info/Warn/Error

* -Debug(面向技术)
* -Info(面向业务)
* -Warn(有错误，不影响功能)
* -Error(有错误，将影响功能)

## 异常处理规范

## 架构规范

## 模型思维

建模的艺术就是去除实在中与问题无关的部分。

这样就可以 聚焦 关系点了

可以简化认知的就是模型

思维模型

概念模型  数学模型  沙盘模型

可以让人身临其境

比如VR  游戏等等  都是很有价值的

UML 数据流图

混沌大学的创始人李善友教授认为，没有好的思维模型，再多的知识积累也是低水平的重复。成人学习的目的不是获取更多的信息量，而是学习更好的思维模型。从本质上讲，思维模型其实是现实世界复杂系统的某个侧面或某个局部的规律，或者近似规律现象的表征工具。对于思维模型，查理·芒格曾给过一个简单定义：任何能帮助你更好理解现实世界的理论框架，都可以称之为思维模型。查理·芒格说：“思维模型会给你提供一种视角或思维框架，从而决定你观察事物和看待世界的视角。顶级的思维模型能提高你成功的可能性，并帮你避免失败。”看起来，思维模型是一种能帮助我们分析问题、解决问题及预测问题的好东西。本书介绍的16种思维能力也是16种思维模型。熟悉这些思维模型等于给你解决问题的工具箱中添加了16种有用的“思维工具”，当面临复杂问题的时候，你可以选择其中一种或多种思维模型去解决问题。

试想一下，你可以熟练地使用抽象思维、分类思维去做领域建模；你可以运用结构化思维做技术规划；在身边人云亦云的时候，你能用逻辑思维、批判性思维理性地分析问题；面对华而不实的复杂设计，你敢于用“奥卡姆剃刀”化繁为简；你能用工具化思维、产品化思维去优化身边的研发环境；你能用分治思维高效地分解问题、解决问题；你能用数据思维、量化思维给业务助力；在面对困难和挑战的时候，你信心十足，因为你相信学习和成长的力量。那么你一定会和其他人不一样！

## 12.3 领域模型

领域

模型是对领域内的概念类或现实世界中对象的可视化表示，又称为概念模型、领域对象模型、分析对象模型。它专注于分析问题领域本身，发掘重要的业务领域概念，并建立业务领域概念之间的关系。这些年来，大家对领域驱动设计(Domain Driven Design, DDD)的关注度一直有增无减，关于领域建模的讨论和学习一直是热点。我想，之所以会这样，一方面是出于对服务划分的需要，另一方面是出于应对复杂度的需要。因为传统的事务脚本（Transaction Script，见链接12-1）模式应付简单业务还可以，但在面对复杂业务场景的时候，领域对象的缺失会导致代码难以被封装、复用，可理解性和可扩展性急剧下降。领域模型将现实世界抽象为了信息世界，把现实世界中的客观对象抽象为某一种信息结构，而这种信息结构并不依赖于具体的计算机系统。领域模型不是对软件设计的描述，和技术无关。

![image.png](./assets/1702563594540-image.png)

## 13 工具化思维

你是否想过，为什么要自己去Mock这些数据呢？我们可不可以自动生成这些数据，有没有可能录制线上的运行数据，然后通过回放数据来做测试呢？这就是工具化思维，也就是我说的“智慧懒”。我们通过工具提效，从而节省大量的工作时间，而不是靠蛮力一遍一遍地重复手工劳动。

13.1 你我都是“工具人”这里的“工具人”，说的是我们都是可以制造工具的人。软件工程师和其他工程师的重要区别之一在于需要自己制造工具。木匠不会自己制造锯子，泥瓦匠不会自己制造铲子，理发师也不会自己制造剪刀。因为这些工具不在其职业能力范围中，他们不具备制造工具的基础。而软件工程师的工作是写代码，工具所需要的要素也是代码，因此制造工具是其能力范围内的事情。

可以说，今天的自动化运维是由工具化造就的，运维工作的本质就是制造工具，比如监控工具、报警工具、调用链路工具、日志工具、持续集成(Continuous Integration, CI)工具、部署工具等。

2015年之前，大部分的公司还处在手工运维阶段，那时还有很多运维工程师的岗位。如图13-5所示，开发工程师负责软件的构建，测试工程师负责质量保证，运维工程师负责软件的发布、部署和维护。随着运维工具越来越完善，标准越来越统一，近些年DevOps已经成为主流。

![image.png](./assets/1702564124132-image.png)

DevOps是一组过程、方法与系统的统称，用于促进开发、运维和质量保障(QA)部门之间的沟通、协作与整合，如图13-6所示。这与Amazon的工程师文化(Someone do everything)是一个意思。从目标来看，DevOps能够让开发人员和运维人员更好地沟通合作，通过自动化流程使得软件整体过程更快捷和可靠。

![image.png](./assets/1702564183874-image.png)

## 14 量化思维

No measurement，no improvement.（没有量化，就无法优化。）——“科学管理之父”温斯洛·泰勒

14.1 量化的步骤一个量化的过程大体上可以分为以下3步。(1)定义指标：仔细分析问题，找到那个可以用来量化问题的关键指标。(2)将指标数字化：围绕关键指标，明确需要哪些数据来实现指标的计算，通过数据收集、数据存储、数据展现去呈现指标，也就是数字化的过程。(3)优化指标：有了数据指标之后，要围绕指标数据迭代优化，达成业务目标。

定义问题永远是我们解决问题的首要任务，而找到那个关键的“北极星”指标对于我们能否用量化思维解决问题至关重要。因为如果目标错了，后面的一切工作都是徒劳的，所以我们要“do the right thing，then do the thing right（做正确的事，然后再正确地做事）”。

在阿里巴巴技术团队有一个说法是“有数据呈现数据，没有数据呈现案例，没有案例呈现观点，如果都没有的话，就请闭嘴”。

再比如，现在国内很多软件企业使用Sonar来实现代码静态质量的把控。为了推进Sonar在团队内的普及，不少企业会用“Sonar项目接入率”（也就是有多少百分比的项目已经在持续集成中启用了Sonar）这样的指标来衡量静态代码检查的普及率。这个指标看似中肯，实际上对于实现最终目标的牵引力是比较有限的。使用Sonar的最终目标是提升代码的质量，只是接入Sonar不仅不能实际改善代码的质量，而且还容易陷入为了接入而接入的指标竞赛。理解了这层逻辑，你会发现使用“Sonar严重问题的平均修复时长”和“Sonar问题的增长趋势”其实更有实践指导意义。

# 接入sonar

![image.png](./assets/1702638747912-image.png)

![image.png](./assets/1702638829557-image.png)

## 15 数据思维


15 数据思维一切业务数据化，一切数据业务化。——阿里巴巴如今的业务越来越离不开数据了，在阿里巴巴内部有一句口号：“一切业务数据化，一切数据业务化。”用户在淘宝上的每一次浏览、每一次点击、每一次搜索等业务行为，都会被沉淀为数据保存起来，这种保存业务过程数据的做法叫作业务数据化。这些数据会帮助淘宝更好地认识用户，当用户下次打开淘宝时，利用这些数据，淘宝就可以更精准地为用户进行智能推荐和广告精准投放，这种用数据赋能业务的方法叫作数据业务化。



15.1 “精通”数据数据如此重要，涉及的内容那么多，工程师需要对数据掌握到什么程度才算合格呢？我认为，我们不一定要做到像数据分析师(Data Analyst, DA)那样精通数据分析，也不一定要像算法专业的博士那样精通算法，但是至少要做到以下两点。(1)要了解公司的数据技术体系。比如，对大数据处理框架、数据仓库、数据分析等有基本的认知，知道其背后的基本原理和运行逻辑。有了这个认知之后，我们就能更好地与数据工程师、数据分析师、商业智能分析师等人员进行分工协作。(2)要知道用数据去说话。我们要学会用数据作为决策的依据，而不是靠猜测、“拳头”或“屁股”去做决策。比如，在与业务方讨论业务需求或与产品经理讨论产品设计的时候，就可以使用数据去佐证我们的判断。这种场景我经历过很多次，对于大家争论了很久的一个问题，在拿出相关数据之后，争论很快就平息了。可见在争论不下的时候，数据是最有说服力的。



15.2 数据体系概览要了解公司的数据体系，我们首先要知道几个问题：在一个公司内部有哪些数据？这些数据是以什么形式存在的？我们要如何使用这些数据？如图15-1所示，一个公司的数据架构可以分为源数据、数据仓库、ETL、元数据管理和数据应用这5个部分。


15.2.1 数据源数据源通常是工程师最熟悉的部分，这些数据一般存储在数据库，比如关系数据库、NoSQL中。客户登录网站的行为、浏览网页的行为等都会被记录入库。客户在网站上的业务操作，比如选购商品、加入购物车、支付订单、评论等业务操作也会入库。关系数据库，是联机事务处理(On-Line Transaction Processing, OLTP)的典型应用。其重点在于“T”，即Transaction，表示面向事务处理。比如，在银行存取一笔钱款，这就是事务交易。为了提升单个数据库的响应时间，现在很多的业务数据库采用了分库分表的设计。比如阿里巴巴的交易表被分在4096个表中，这样即使有4000亿条数据，每个表也只分担大概1亿条数据，因此单库的性能依然很好。




## 16 产品思维

产品就是用来解决某个问题的东西。——苏杰《人人都是产品经理》工程思维和产品思维是不一样的。工程师追求技术至上，产品经理追求商业价值和用户体验；工程师关注细节，产品经理关注全局；工程师关注How（如何做），产品经理关注Why（为什么）。结合两种思维方式，可以让思考更全面和系统化。


比如，要改进一款拍照软件，工程师与产品经理会有不同的思路。工程思维在于如何提升防抖功能、如何提升相机像素等；而产品思维在于如何轻松美图、如何分享炫耀等，更多关注的是用户体验，以及用户深层次的本质需求。准确地说，产品经理并不是一个专业，所谓“人人都是产品经理”是有一定道理的。在这个“鱼龙混杂”的队伍中，牛人很多，“传话筒”也很多。“传话筒”产品经理自己不思考，只会传老板的话、传客户的话、传运营的话，就是不用产品说话，导致有很多“劳民伤财”的伪需求被直接传送到开发人员这边。这样做不仅伤害了用户，也辜负了技术人员的付出。


16.1 产品的三要素产品的目的是帮助我们解决问题，产品化思维就是站在用户的视角去解决用户的问题。产品力代表了企业的竞争力，如图16-1所示，产品对上要承接客户价值，对下要负责业务功能的实现和质量属性（稳定性、可用性、安全性等）。

了解产品思维，关键要理解产品的三个核心要素：**用户、需求、场景。**

![image.png](./assets/1702733552618-image.png)


## 16.1.1 用户

用户是产品要服务的对象，即使用产品的人。用户是“上帝”，产品成功的关键在于是否能够满足用户的需求，产品化思维的关键也正在于此。这里需要注意的是，客户(Customer)和终端用户(End User)可能不是一个人。对于玩具来说，成年人购买玩具（比如游戏机）时，客户和终端用户这两个角色是重叠的，背后是同一个自然人；但成年人给小朋友购买玩具时，角色就分离了——客户是小朋友的父母，是为产品买单的人，而终端用户是小朋友。


## 16.1.2 需求

需求即产品要解决的核心问题是什么。

**需要注意的是，需求是分层次的，最浅一层是需求的表象；第二层是观点和背后的目的；最深一层是人性，每个需求挖到最后，都可以归结到人性层面。**

以做技术培训的极客时间为例。第一层，需求的表象是学员想学技术。第二层，背后的目的是学员希望提升技术能力，这也是极客时间对课程质量要求这么高的原因，其目的是让学员有获得感，能真正提升技术能力。第三层，是人性的东西。比如，提升技术能力的动机可能是为了挣更多的钱、获得他人的尊重、提升社会地位、实现个人价值。从第三层需求的层面出发，如果我是极客时间的产品经理，我会考虑做一个证书产品。比如，将3门Java相关的课程打包起来，对于学完这3门课程的学员，给其颁发一个“Java专家”的认证。不管是纸质版，还是电子版认证，都必须提供本人真实照片，目的是方便学员在拿到证书以后在朋友圈中“展示”一下。


## 16.1.3 场景

场景即用户何时何地需要使用产品。以知识付费产品为例，为什么几乎所有的知识付费产品（包括极客时间）都会做音频内容呢？这是因为大部分的用户会选择在上下班的途中给自己“充电”，而这段时间，无论是自己开车，还是坐公共交通工具，最方便的当然就是听音频了。总结一下，产品思维的关键是要站在用户的视角思考问题，想办法挖掘用户的真正需求，真正的需求往往是在表象之后的，所以我们要聆听客户的想法，但不要完全照着做。最后，产品功能和场景是密切相关的，只有符合场景需要的产品才是好产品。

16.2.1 用户关系角度从产品与用户关系的角度，可以把产品分为3类：单点、单边、多边。其中，多边又可以分为双边、三边等。举例来说，计算器是典型的单点用户型产品，只要有一个用户使用，就能产生完整的用户价值；电话是典型的单边用户型产品，需要一群人同时使用，只有一个人有电话是没有意义的，使用这个产品的用户越多，价值越大，产品也就有了网络效应；多边用户型产品一般是平台级产品，需要几群不同的人一起使用才能产生价值，最典型的如知乎——由提问者、回答者、围观者构成三边，其中沉淀了很多内容和关系。



从用户需求角度，可以把产品分为6类：工具、内容、社交、交易、平台、游戏。这个分类的界限并没有那么严格，很多产品是多个分类的混合体。(1)工具：解决单点问题。工具用来解决特定的单点问题，可以“用完即走”。计算器、词典、解压软件，以及常用的支付和天气的应用都是典型的工具。大多数工具是典型的单点产品，启动容易，可以快速解决流量问题，但弱点在于黏性低。(2)内容：价值观过滤器。我们必须提供有价值的信息，如果用户想打发时间，那么“可打发时间”也算一种价值。(3)社交：彼此相互吸引。用户与用户彼此吸引并建立关系，最终因此而留下来。(4)交易：做生意卖东西。线上的交易就是电商和O2O概念下的各种收费服务。交易产品是天然有现金流的，看到了现金，离盈利模式就更近一步。(5)平台：复杂的综合体。这是一种同时满足多种角色的产品形态，也可以说是“生态”。如今，很少有只单纯满足一种用户需求的产品，而平台产品就是最典型的综合体之一，其中可能有工具、内容、社交、交易、游戏等各种元素。(6)游戏：打造平行世界。可大可小，一切皆可包容，是真实世界的副本。游戏中可以融合社交、交易等元素，甚至可以将游戏理解为被创造出来的“


用户类型角度产品的用户多种多样，但我们最常听到是2B和2C这两类，它们分别是英文to Business与to Customer的缩写。最典型的，百度的产品经理就分两大类：2B的商业型产品经理和2C的用户型产品经理，因为这两种产品区别真的很大；还有些小众的，比如2G(to Government)即面向政府部门、2D(to Developer)即面向开发者，其实它们也都可以归类到2B或2C中。
