# 第一部分 基础思维能力

## 01 抽象思维

就是抽象 ，合理的抽象。

这部分主要介绍解决日常问题的基础思维能力。这些思维能力不受行业的局限，比如我们在解决数学问题时需要动用抽象思维和逻辑思维；结构化思维更多地被用在写作和表达中；在当今信息爆炸的时代，每个人都需要有一些批判精神，这是批判性思维；化繁为简是我们要一直追寻的目标，这需要具备简单思维；面对困难，要有成长型思维；等等。

1.1 抽象=抽离+具象在《西方哲学史》中，奥古斯丁说：“至于什么是时间，在没人问我时，我非常清楚；可一旦要向别人解释，我就有点糊涂了。”对于抽象的概念也是如此，很多人都介于“懂”但是又“说不清楚”的模棱两可状态，不妨让我们先从定义开始来揭开“抽象”的神秘面纱。

## 怎么起变量名

这也是我在做设计和代码审查(Code Review)的时候，会特别关注命名是否合理的原因。因为命名的好坏在很大程度上反映了我们对一个概念的思考是否清晰、抽象是否合理，反映在代码上就是代码的可读性、可理解性是否良好，以及我们的设计是否到位。有人做过一个调查，问程序员最头疼的事情是什么。Quora和Ubuntu Forum的调查结果显示，程序员最头疼的事情是命名。如果你曾经为了一个命名而绞尽脑汁，就不会对这个结果感到意外。正如Stack Overflow的创始人Joel Spolsky所说：“Creating good names is hard，but it should be hard，because a great name captures essential meaning in just one or two words.”（起一个好名字应该很难，因为，一个好名字需要把要义浓缩在一到两个词中。）

我想强调的是：语言是明晰概念的基础，也是抽象思维的基础，在构建一个系统时，值得我们花很多时间去斟酌和推敲语言。我曾经做过一个项目，在过程中针对一个关键实体讨论了两天，因为那是一个新概念，我们尝试了很多名字，却始终感觉别扭、不好理解。随着讨论和对问题域理解的深入，我们最终找到了一个相对比较合适的名字，才算罢休。这样的斟酌是有意义的，因为明晰关键概念是我们设计中的重要工作。虽然不合理的命名和不合理的抽象也能实现业务功能，但代价就是维护系统时的极高的认知负荷。随着时间的推移，也许就没人能搞懂系统为何这样设计了。

软件设计是单纯的思维创造活动，其中最关键的是抽象思维。可以说，抽象是软件设计的核心，特别是在面向对象设计中，如果没有好的抽象概念，就不可能设计和编写出好的面向对象(Object Oriented, OO)程序。1.4.1 面向对象的核心是抽象作为当今最重要的软件工程技术之一，面向对象(Object Oriented, OO)技术实际上由3个部分组成，分别是面向对象分析(Object Oriented Analysis, OOA)、面向对象设计(Object Oriented Design, OOD)和面向对象编程(Object Oriented Programming, OOP)。

## 如何抽象

1.4.4 抽象缺失之重复代码如果说抽象源于对共性的提取，那么代码中的重复代码是不是就意味着抽象缺失呢？重复代码是典型的代码坏味道，其本质问题就是抽象缺失。使用“Ctrl+C”加“Ctrl+V”的工作习惯导致没有对共性代码进行抽取，或者虽然抽取了，但没有设置一个合适的名字，没有正确地反映这段代码所体现的抽象概念，这些都属于抽象不到位。

由此可见，提取重复代码只是重构工作的第一步。对重复代码进行概念抽象，寻找有意义的命名才是我们工作的重点。因此，每次遇到重复代码需要重构的时候，你都应该感到兴奋，这是一次锻炼抽象能力的绝佳机会。

## 判断抽象是否完整

1.4.5 抽象设计要完整好的抽象设计是内聚而完整的。为了支持相关的方法，可能会影响抽象的内聚性和完整性。例如，要在数据结构中添加和删除元素，抽象该数据结构的类型必须同时支持方法add()和remove()；如果只支持相关方法中的一个，那么抽象设计就不是内聚和完整的。例如，在JDK 1.1的接口javax.swing.ButtonModel中，只提供了setGroup()方法，而没有提供getGroup()，这是一种典型的“不完整的抽象设计”坏味道。修复它的最理想的方法是在这个接口中定义方法getGroup()，然而由于JDK是公开的API，在接口上添加方法将破坏实现了该接口的既有类。为了向后兼容，在JDK 1.3中，将方法getGroup()加入了派生类DefaultButtonModel中。

## 中台的必要性： 是否是好的抽象

实际上，公司经营的B2C电商业务和电影票业务，在交易形态上有较大的区别，尤其体现在订单模块的设计上，订单的状态机、数据模型和财务账务处理模式完全不同。两者并没有太多的共性模块和功能，强行将两者合并后，最终只是表面上看起来实现了订单中台，但是其中的功能模块各自独立运转，完全没有实现抽象和复用。现在，公司管理者以为拥有了强大的订单中台，可以为快速开展新业务提供支持。很快，公司决定开展机票售卖业务，针对机票业务，有独立的C端、商品管理、促销管理。但是当产品经理和工程师开始期待订单中台的强大功能时，却遗憾地发现：订单中台无法给机票业务提供任何现成的功能复用能力，机票的订单模型和电商、电影票都不相同。

![image.png](./assets/1701873473923-image.png)

可见，在不同的业务模式下，订单中心并不一定适用于中台化建设，设计人员要有足够的思辨能力，判断产品形态上是否值得抽象下沉、是否能够提供复用能力。然而，这也是软件工程设计中非常难的部分。任何软件系统的设计都基于归纳法，而非演绎法，即软件设计人员总是通过对现有世界和业务的总结提炼，**而无法通过推测演绎完成软件设计。设计人员无法对业务的未来做出预测，只能基于有限的经验，尽量保证设计的灵活性和正确性。**

理解这一点非常重要，这会让你在软件设计、产品设计时心存敬畏，不会因一味地追求短期无法论证的结论而产生严重的过度设计。在实践中，对于基于抽象复用的平台建设，有以下几条建议。(1)对于明显具备共性的模块，尽早抽象。在B端产品的体系化设计中，很多形态的产品是具备明显共性的，我们可以尽早地进行抽象设计，这样在系统架构建设的早期就能做出正确的设计方案，而且并不会过多地增加研发工作量，相反会让未来的系统扩展更加轻松。例如，业务系统中的统一权限管理系统、单点登录系统、组织架构系统、公告系统、短信系统等，都应该尽早完成抽象建设。(2)对于共性不确定的模块，事后抽象。对于统一客户视图、订单中心、商品系统等软件模块，很难判断在多业务线场景下是否能够完全复用。如果对于是否进行抽象拿不准主意，那么完全可以先不做，等业务渐渐明确后，有足够的信息做出充分的分析和判断时，再决定是否合并抽象设计。


## 02 逻辑思维

2.2.1 概念要明确且清晰对概念的明晰和定义是我们设计过程中的重要内容。在一个领域内，如果一个系统的核心概念的定义出现了问题，可能会给上层的业务带来毁灭性的打击。此前我们在做社区团购业务的时候，由于系统是从盒马交接过来的，而在之前的系统中并没对商品、货品这两个重要概念进行区分，导致后续出现了领域边界不清、团队职责不清、系统修改困难等一系列问题。例如，我负责的商品系统对外会被供应链、仓库物流消费使用。作为商业的基本要素，商品被外部系统依赖本来也是正常的，只是原来的系统并没有清晰地明确商品和货品的概念，导致商品系统在承载商品管理职责的同时，还承载了货品的职责。管理的是商品，发布的是商品，采购的是商品，销售的是商品，仓内扫码作业还是商品。这种不区分上下文地使用“商品”这个概念，导致商品就像洪水一样以一种模糊的方式泛滥到各个系统中。

![image.png](./assets/1701950352143-image.png)

![image.png](./assets/1701950362253-image.png)![image.png](./assets/1701950372840-image.png)


2.4 逻辑三要素之推理前面提到，逻辑就是关系。



所谓推理，就是研究语句、判断、命题之间相互关系的学问。逻辑推理可以分为演绎推理(Deductive Inference)、归纳推理(Inductive Inference)和溯因推理(Abductive Inference)。

这也是为什么有很多哲学家认为归纳法虽然可以得到新知识，但是因为不能穷举，所以永远也得不到真理。然而，演绎法虽然可以保真，但因为结论蕴含在大前提中，又不能产出新知识，因此如果最后推导出有真理存在，那么真理只能是先验的（先于我们的感觉经验，先天存在于我们的意识之中）。然而科学知识都是来自科学归纳法的，所以真正的科学都是可以被证伪的，即当一种科学理论与最新的发现发生矛盾的时候，就需要一种新的理论来代替它。爱因斯坦的相对论虽然在牛顿力学的基础上迈出了一大步，但还是受到了量子力学的挑战，因此我们还需要一个能够解释所有力学现象的统一场论。这也是爱因斯坦终其一生都没有完成的工作，只能期待另一个“爱因斯坦”来完成了。

实际上，归纳和演绎并不是割裂的，而是彼此联系的，主要有以下两个原因。(1)为了提高归纳推理的可靠程度，需要运用已有的理论知识对归纳推理的个别性前提进行分析，把握其中的因果性、必然性，这就要用到演绎推理。(2)归纳推理依靠演绎推理来验证自己的结论。同样，演绎推理要以一般性知识为前提，这通常要依赖归纳推理来提供一般性知识。这一点在软件工程的建模工作中得到了充分的体现，建模是一个归纳工作，我们通过抽象问题域里具有共同特性的类来建立模型。为了验证模型的有效性，我们会使用演绎的方法去推演不同的业务场景，看看模型是否能满足业务的需要。这样的工作往往不是一次成型的，而是交替往复，最终才能得到一个相对合理的模型。


比如，我们收到系统异常报警后去查看系统日志，发现是一个依赖服务报了超时(Timeout)错误。我们的第一反应是：是不是网络出现了问题（假设）？接下来开始ping依赖服务的IP，发现网络没问题（求证）。于是我们提出了新的假设：是不是依赖服务内部出现了什么问题？接下来开始排查依赖服务的日志，发现是因为一个数据库操作过于频繁，导致响应时间超时。

可是这部分的代码很长时间没有修改了，为什么偏偏今天出现问题呢？

通过进一步排查，我们发现是缓存服务器出现了问题，导致本来调用缓存的操作全部被打到了数据库上。那么为什么缓存服务器会宕机呢？

通过进一步追查，发现是最近使用缓存的人比较多，内存空间不足导致了宕机。至此，我们才算真正找到了问题的根因(Root Cause)。



![image.png](./assets/1701951114155-image.png)
