# 第一章修改软件

## 1.1修改软件的四个起因

为了简明起见，让我们来看看修改软件的四个 要起因
(1) 添加新特性:
(2) 修正bug;
(3) 改善设计:
(4) 优化资源使用

### 1.1.1 添加特性和修正bug

假设我们正在构建 个基于Web的应用，这时经理告诉我们她(指客户)想要把公司的logo
从页面的左侧移到右侧 于是我们与她交谈，发现这件事情并不是想象中那么简单。她不但要移
logo. 还想进行其他改动。她希望在系统的下 个版本中能够让它动起来 那么，这算是修正
bug还是添加新特性呢? 答案取决于你看待这个问题的角度

在客户的眼里它是 bug修正，而在开发看来则是添加新特性，就这么简单。

想要完全不改变现有行为地添加新行为几乎是不可能的

### 1.1.2 改善设计

重构与一般的代码清理不同，在重构时我们并不只是在做那些低危险性的工作(如重整源代码的格式)或侵入性的危险工作(如重写代码块)，而是进行一系列的结构 的小改动，并通过测试的支持来使得代码的修改更容易着手。

从改变的角度来说，重构的关键在于在进行重构的过程中不应当有任何功能上的改变。(不过行为可以稍有改变，因为你在代码结构上的改动可能会导致性能上的改变，其性能可能会变得更差 ，也可能会变得好一点。)

### 1.1.3 优化

优化与重构类似，但目标不同 。对于重构和优化，我们都可以说"我们在进行修改的过程
中将会保持功能不变，但我们可能会改变某些其他东西 "对于重构来说，这里的"某些其他东西"就是指程序的结构，我们想让代码更容易维护。而对于优化来说"某些其他东西"则是指程序所使用的某些资源，通常指时间或内存。

比如模块运行的内存占用过高，需要优化。

或者接口的延时过长。

### 1.1.4 综合对比

重构与优化的相似性看起来似乎有点奇怪。它们彼此间的相似性看上去比添加特性与修正
bug之间的相似性还要高。然而，真的是这样吗?重构与优化之间的共同点就是在改变某些东西
的过程中保持软件的功能不变

保留既有行为不变是软件开发中最具挑战性的任务之一 即使是在改变主要特性时，通常
也有很多行为是必须保留不交的

## 1.2 危险的修改

行为保持是一项巨大的挑战。在我们需要作出修改并保持行为时，往往伴随 当大的风险。
为了减小风险，我们要考虑下面这 个问题.
(1) 我们要进行哪些修改?
(2) 我们如何得知已经正确地完成了修改?
(3) 我们如何得知没有破坏任何(既有的〉东西?
如果所作改动是有风险的话，你能够承担得起多少改动?

我曾共事过的大多数团队都曾试图以 种非常传统的方式来控制风险。他们把对代码基的改
动数量降至最低 有时候这是一种团队策略"如果没有被破坏，就别去修正。"开发者在进行修改
的时候是非常谨慎的"什么?为此创建 个新方法?不不不，我还是把这几行代码直接放到这个
现成的方法里面算了，这样我就可以看到新老代码在 。况且这种做法费力少，也更为安全
人们可能会认为可以通过"避免" 二字诀来将软件问题的数量降至最低，然而遗憾的是，问
题总是不可避免。

当我们避免创建新类和新方法时，既有的类和方法就会变得越来越庞大，越来
越难以理解。当在任何大型系统中进行修改时，你可能需要 点时间来熟悉一下将要修改的区域。
**这时好的系统和 的系统之间的差别就体现出来了。对于前者，当你熟悉了待修改的区域之后，
你会对将要进行的修改充满信心。**而对于那些结构糟糕的代码，从理清存在的问题着手进行修
改的过程简直就像是为了**躲避一只老虎而跳下悬崖一样痛苦**。你一再犹疑"我真的准备好这么
做了吗?晤，好吧，我想我别无选择

# 第2章 带着反馈工作

什么可以作为反馈，测试。

当要动手进行改动的区域由测试包围着时，这些测试的作用就好 一把"软件夹钳"
你可以用这把"软件夹钳"来固定住目标软件的大部分行为，只改动那些你真正想要改动的地方。

回归测试是一个好主意。那么为什么人们不更频繁地进行回归测试呢?这是因为回归测试存
在着一个小问题 通常进行回归测试时，都是在应用程序接口 (application interface) 层面进行
测试。不管目标应用是Web应用、命令行程序，还是GUI程序，回归测试在传统上都是看作
应用层面的测试。然而这只是一个不幸的传统观念。事实上，我们从回归测试中得到的反馈信息
是非常有用的。所以若能把回归测试运用到 个更细粒度的层面则将是大有神益的。

在进行代码重构或者优化时：

可以使用单元测试来做。

我们开始对代码做重构.我们将一些方法抽取出来，并移动一些条件逻辑。在进行的
每一步细小的改动后，我们都会运行上面提到的那套单元测试。几乎我们每次运行它的时候都是
通过的。就在儿分钟前我们犯于 个错误，反转了 个条件逻辑，然而单元测试迅速给出了失败
的结果，于是我们得以在大约一分钟内纠正了所犯的错误。当我们完成重构之后，代码变得清晰
多了。我们完成了要做的改动，而且确信我们的改动是正确的。接下来，我们添加了几个测试
验证新加上去的特性.于是，面对这些代码的下 个程序员做起来就会轻松得多，而且他会有覆
盖其所有功能的全套测试。
你是希望在→分钟内就获得反馈呢?还是希望等 整个晚上 以上哪个场景更有效率?
单元测试是用于对付遗留代码的极其重要的组件之一.系统层面的回归测试的确很棒，然而
相比之下，小巧而局部性的测试才是无价之宝，它们能够在进行改动的过程中不断给你反馈，使
重构工作的安全性大大增强。

## 2.1 什么是单元测试

大型测试存在的问题：

错误定位需要耗费的工作更多，

执行时间比较久

下面是好的单元测试所应具备的品质:
(1)运行快:
(2) 能帮助我们定位问题所在。

在业界，人们在判断某个特定的测试是否是单元测试这个问题上常常摇摆不定。如果一个测
试中涉及了另外一个产品类，那它还能算是单元测试吗?为了回答这个问题，我们回到刚才提到
的两点品质上来，即该测试运行起来快不快?它能帮我们快速定位错误吗?比如有些测试较大，
其中用到了好多类。那么实际上这种测试或许看上去像是小型的集成测试。

一个需要耗时十分之 秒才能执行完的羊元测试就已算是一个慢的单元测试了.
我说这话是认真的。在我 作本书时，十分之 秒对于单元测试来说简直就像一个世纪 样。

### 哪些不是单元测试

单元测试运行得快.运行得不快的不是单元测试。
有些测试容易跟单元测试混淆起来.譬如下面这些测试就不是单元测试·
(1) 和数据库有交互，
(2) 进行了网络间通信，
(3) 调用了文件系统，
(4) 需要你对环境作特定的准备(如编辑配直文件)才能运行的.
当然，这并不是说这些测试就是坏的.编写它们常常也是有价值的，而且你通常也会在单
元测试用具内来编写它们。然而，将它们;;r<-真正的单元测试区分开来还是很有必要的，因为这
样你就能够知道哪些测试是你可以(在你进行代码修改的时候)快速运行的.

### 对于有着较强依赖的类或方法怎么安排合适的测试？

**当 个类直接依赖于某些难以在测试中使用的东西时，这个
类就是难以修改和处理的**比如：

![image.png](./assets/1699166837723-image.png)

在上面的lnvoice例子当中，我们可以试着在一个更高的层别来进行测试。如果对于某个特定
的类来说，不改变它就难以为它编写测试的话，那么转而去测试使用它的那些类往往会简单一些。
然而不管怎么样，我们通常最终还是免不了要在某个点上解开类之间的依赖。在当前的这个例子
中，我们可以解开 nvoiceUpdateResponder~-InvoiceupdateServlet 的依赖.只需将
InvoiceUpdateResponder真正需要的东西传给它就行。 InvoiceUpdateResponder需要的是
InvoiceUpdateServlet 所持有的一组发票由。同样，我们也可以解开 InvoiceUpdateResponder对于DBConnection 的依赖: 需引入个接口 (IDBConnectio口)并将工nVOlceD@Q UpdateResponder 改为使用该接口即可。图 -2展示了这些类在上述改动之后的样子和关系。

那么，在没有测试保护的情况下进行上述的重构到底安不安全呢?实际上它们可以是安全
的。上述的用于解开InvoiceUpdateResponder InvoiceUpdateServlet和对DBConnection
的依赖的两种重构手法分别称作朴素化参数 Primitivize Parameter. 302页) 和接口提取 CExtract
Interface . 285 页)。在本书的最后，解依赖的技术 部分中对它们有详细描述。在解依赖时，我
们通常可以采用编写测试的手段来让较具侵入性的修改更为安全。诀窍就在于要非常保守地进行
上述最初的重构。

# 第三章 感知和分离
