# 第一章修改软件

## 1.1修改软件的四个起因

为了简明起见，让我们来看看修改软件的四个 要起因
(1) 添加新特性:
(2) 修正bug;
(3) 改善设计:
(4) 优化资源使用

### 1.1.1 添加特性和修正bug

假设我们正在构建 个基于Web的应用，这时经理告诉我们她(指客户)想要把公司的logo
从页面的左侧移到右侧 于是我们与她交谈，发现这件事情并不是想象中那么简单。她不但要移
logo. 还想进行其他改动。她希望在系统的下 个版本中能够让它动起来 那么，这算是修正
bug还是添加新特性呢? 答案取决于你看待这个问题的角度

在客户的眼里它是 bug修正，而在开发看来则是添加新特性，就这么简单。

想要完全不改变现有行为地添加新行为几乎是不可能的

### 1.1.2 改善设计

重构与一般的代码清理不同，在重构时我们并不只是在做那些低危险性的工作(如重整源代码的格式)或侵入性的危险工作(如重写代码块)，而是进行一系列的结构 的小改动，并通过测试的支持来使得代码的修改更容易着手。

从改变的角度来说，重构的关键在于在进行重构的过程中不应当有任何功能上的改变。(不过行为可以稍有改变，因为你在代码结构上的改动可能会导致性能上的改变，其性能可能会变得更差 ，也可能会变得好一点。)

### 1.1.3 优化

优化与重构类似，但目标不同 。对于重构和优化，我们都可以说"我们在进行修改的过程
中将会保持功能不变，但我们可能会改变某些其他东西 "对于重构来说，这里的"某些其他东西"就是指程序的结构，我们想让代码更容易维护。而对于优化来说"某些其他东西"则是指程序所使用的某些资源，通常指时间或内存。

比如模块运行的内存占用过高，需要优化。

或者接口的延时过长。

### 1.1.4 综合对比

重构与优化的相似性看起来似乎有点奇怪。它们彼此间的相似性看上去比添加特性与修正
bug之间的相似性还要高。然而，真的是这样吗?重构与优化之间的共同点就是在改变某些东西
的过程中保持软件的功能不变

保留既有行为不变是软件开发中最具挑战性的任务之一 即使是在改变主要特性时，通常
也有很多行为是必须保留不交的

## 1.2 危险的修改

行为保持是一项巨大的挑战。在我们需要作出修改并保持行为时，往往伴随 当大的风险。
为了减小风险，我们要考虑下面这 个问题.
(1) 我们要进行哪些修改?
(2) 我们如何得知已经正确地完成了修改?
(3) 我们如何得知没有破坏任何(既有的〉东西?
如果所作改动是有风险的话，你能够承担得起多少改动?

我曾共事过的大多数团队都曾试图以 种非常传统的方式来控制风险。他们把对代码基的改
动数量降至最低 有时候这是一种团队策略"如果没有被破坏，就别去修正。"开发者在进行修改
的时候是非常谨慎的"什么?为此创建 个新方法?不不不，我还是把这几行代码直接放到这个
现成的方法里面算了，这样我就可以看到新老代码在 。况且这种做法费力少，也更为安全
人们可能会认为可以通过"避免" 二字诀来将软件问题的数量降至最低，然而遗憾的是，问
题总是不可避免。

当我们避免创建新类和新方法时，既有的类和方法就会变得越来越庞大，越来
越难以理解。当在任何大型系统中进行修改时，你可能需要 点时间来熟悉一下将要修改的区域。
**这时好的系统和 的系统之间的差别就体现出来了。对于前者，当你熟悉了待修改的区域之后，
你会对将要进行的修改充满信心。**而对于那些结构糟糕的代码，从理清存在的问题着手进行修
改的过程简直就像是为了**躲避一只老虎而跳下悬崖一样痛苦**。你一再犹疑"我真的准备好这么
做了吗?晤，好吧，我想我别无选择

# 第2章 带着反馈工作

什么可以作为反馈，测试。

当要动手进行改动的区域由测试包围着时，这些测试的作用就好 一把"软件夹钳"
你可以用这把"软件夹钳"来固定住目标软件的大部分行为，只改动那些你真正想要改动的地方。

回归测试是一个好主意。那么为什么人们不更频繁地进行回归测试呢?这是因为回归测试存
在着一个小问题 通常进行回归测试时，都是在应用程序接口 (application interface) 层面进行
测试。不管目标应用是Web应用、命令行程序，还是GUI程序，回归测试在传统上都是看作
应用层面的测试。然而这只是一个不幸的传统观念。事实上，我们从回归测试中得到的反馈信息
是非常有用的。所以若能把回归测试运用到 个更细粒度的层面则将是大有神益的。

在进行代码重构或者优化时：

可以使用单元测试来做。

我们开始对代码做重构.我们将一些方法抽取出来，并移动一些条件逻辑。在进行的
每一步细小的改动后，我们都会运行上面提到的那套单元测试。几乎我们每次运行它的时候都是
通过的。就在儿分钟前我们犯于 个错误，反转了 个条件逻辑，然而单元测试迅速给出了失败
的结果，于是我们得以在大约一分钟内纠正了所犯的错误。当我们完成重构之后，代码变得清晰
多了。我们完成了要做的改动，而且确信我们的改动是正确的。接下来，我们添加了几个测试
验证新加上去的特性.于是，面对这些代码的下 个程序员做起来就会轻松得多，而且他会有覆
盖其所有功能的全套测试。
你是希望在→分钟内就获得反馈呢?还是希望等 整个晚上 以上哪个场景更有效率?
单元测试是用于对付遗留代码的极其重要的组件之一.系统层面的回归测试的确很棒，然而
相比之下，小巧而局部性的测试才是无价之宝，它们能够在进行改动的过程中不断给你反馈，使
重构工作的安全性大大增强。

## 2.1 什么是单元测试
