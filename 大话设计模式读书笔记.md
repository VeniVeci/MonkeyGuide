## 策略模式

为什么为True 但是不会进去呢

因为 encoding 不对

无折扣是GBK 编码  equals在使用的时候

![image.png](./assets/1700493010630-image.png)

你问我？你说呢？”大鸟笑道，“商场收银时如何促销，用打折还是返利，其实都是一些算法，用工厂来生成算法对象，这没有错，但算法本身只是一种策略，最重要的是这些算法是随时都可能互相替换的，这就是变化点，而封装变化点是我们面向对象的一种很重要的思维方式。我们来看看策略模式的结构图和基本代码。

策略模式的优点

1“策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能

2 策略模式的优点是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试[DPE]。”“每个算法可保证它没有错误，修改其中任一个时也不会影响其他的算法。这真的是非常好。”

# 第三章 单一职责原则

就是一个类最好职责明确

就一个类而言，应该仅有一个引起它变化的原因

比如我要修改这个代码的界面 那么就去界面类中修改

如果是修改算法 那就去算法类

# 第四章 考研求职两不误——开放-封闭原则

扩展的思想也是最重要的一种设计原则，它就是开放-封闭原则（The Open-Closeed Principle，简称OCP）或叫开-闭原则。

开放-封闭原则，是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改

## 如何应对变化

小菜：“啊，有道理。所以，我们尽量应在设计时，考虑到需求的种种变化，把问题想得全了，就不会因为需求一来，手足无措。”大鸟：“哪有那么容易，如果什么问题都考虑得到，那不就成了未卜先知，这是不可能的。需求时常会在你想不到的地方出现，让你防不胜防。”小菜：“那我们应该怎么做？”大鸟：“开放-封闭原则的意思就是说，你设计的时候，时刻要考虑，尽量让这个类是足够好，写好了就不要去修改了，如果新需求来，我们增加一些类就完事了，原来的代码能不动则不动。

### 案例

大鸟：“在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化[ASD]。比如，我之前让你写的加法程序，你很快在一个client类中就完成，此时变化还没有发生。然后我让你加一个减法功能，你发现，增加功能需要修改原来这个类，这就违背了今天讲到的‘开放-封闭原则’，于是你就该考虑重构程序，增加一个抽象的运算类，通过一些面向对象的手段，如继承，多态等来隔离具体加法、减法与client耦合，需求依然可以满足，还能应对变化。这时我又要你再加乘除法功能，你就不需要再去更改client以及加法减法的类了，而是增加乘法和除法子类就可。即面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码[ASD]。这就是‘开放-封闭原则’的精神所在。”（样例代码见第1章）

# 第五章 会修电脑不会修收音机？——依赖倒转原则

“蓝屏通常是内存本身有问题或内存与主板不兼容，主板不容易换，但内存更换起来很容易。”“如果是别的部件坏了，比如硬盘，显卡，光驱等，是否也只需要更换就可以了？”“是呀，确实很方便，只需要懂一点点计算机知识，就可以试着修电脑了。”

面向对象的四个好处？”“这个我记得最牢了，就是活字印刷那个例子呗。是可维护、可扩展、可复用和灵活性好。

CPU的强内聚的确是强。但它又独自成为了产品，在千千万万的电脑主板上插上就可以使用，这是什么原因？”大鸟又问。“因为CPU的对外都是针脚式或触点式等标准的接口。啊，我明白了，这就是接口的最大好处。CPU只需要把接口定义好，内部再复杂我也不让外界知道，而主板只需要预留与CPU针脚的插槽就可以了。”

PC的接口是有限的，所以扩展有限，软件系统设计得好，却可以无限地扩展。这两个原则我们之前都已经提过了。这里需要重点讲讲一个新的原则，叫依赖倒转原则，也有翻译成依赖倒置原则的。”大鸟接着讲道，“依赖倒转原则，原话解释是抽象不应该依赖细节，细节应该依赖于抽象，这话绕口，说白了，就是要针对接口编程，不要对实现编程，无论主板、CPU、内存、硬盘都是在针对接口设计的，如果针对实现来设计，内存就要对应到具体的某个品牌的主板，那就会出现换内存需要把主板也换了的尴尬

依赖倒转原则A．高层模块不应该依赖低层模块。两个都应该依赖抽象。B．抽象不应该依赖细节。细节应该依赖抽象。[ASD]

如果不管高层模块还是低层模块，它们都依赖于抽象，具体一点就是接口或抽象类，只要接口是稳定的，那么任何一个的更改都不用担心其他受到影响，这就使得无论高层模块还是低层模块都可以很容易地被复用。这才是最好的办法。”

依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了[ASD]。”“是的是的，我听说很多银行目前还是纯C语言的面向过程开发，非常不灵活，维护成本是很高昂的。”“那也是没办法的，银行系统哪是说换就换的，所以现在是大力鼓励年轻人学设计模式，直接面向对象的设计和编程，从大的方向上讲，这是国家大力发展生产力的很大保障呀。”

## 里氏代换原则

“里氏代换原则是Barbara Liskov女士在1988年发表的[ASD]，具体的数学定义比较复杂，你可以查相关资料，它的白话翻译就是一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化，简单地说，子类型必须能够替换掉它们的父类型[ASD]。”里氏代换原则（LSP）：子类型必须能够替换掉它们的父类型。[ASD]“这好像是学继承时就要理解的概念，子类继承了父类，所以子类可以以父类的身份出现。”“是的，我问你个问题，如果在面向对象设计时，一个是鸟类，一个是企鹅类，如果鸟是可以飞的，企鹅不会飞，那么企鹅是鸟吗？企鹅可以继承鸟这个类吗”“企鹅是一种特殊的鸟，尽管不能飞，但它也是鸟呀，当然可以继承。”“哈，你上当了，我说的是在面向对象设计时，那就意味着什么呢？子类拥有父类所有非private的行为和属性。鸟会飞，而企鹅不会飞。尽管在生物学分类上，企鹅是一种鸟，但在编程世界里，企鹅不能以父类——鸟的身份出现，因为前提说所有鸟都能飞，而企鹅飞不了，所以，企鹅不能继承鸟类。”

# 第6章　穿什么有这么重要？——装饰模式

要求你写一个可以给人搭配不同的服饰的系统，比如类似QQ、网络游戏或论坛都有的Avatar系统。你怎么开发

装饰者模式

装饰模式（Decorator），动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。[DP]“啊，装饰这词真好，无论衣服、鞋子、领带、披风其实都可以理解为对人的装饰。”

装饰模式的优点我总结下来就是，把类中的装饰功能从类中搬移去除，这样可以简化原有的类。”“是的，这样做更大的好处就是有效地把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复的装饰逻辑。”

# 第7章　为别人做嫁衣——代理模式

代理模式   java中就是 invoke

可以用来增强代码

aop就用到了

怎么做到

需要反射

既然都可以增强功能  那么

## 和装饰者模式的区别



## 应用场景

“那代理模式都用在一些什么场合呢？”小菜问道。“一般来说分为几种，第一，远程代理，也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实[DP]。”


# 第11章　无熟人难办事？——迪米特法则


迪米特法则（LoD），如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。

“迪米特法则首先强调的前提是在类的结构设计上，每一个类都应当尽量降低成员的访问权限[J&DP]，也就是说，一个类包装好自己的private状态，不需要让别的类知道的字段或行为就不要公开。”“哦，是的，需要公开的字段，通常就用属性来体现了。这不是封装的思想吗？


同样道理，我们在程序设计时，类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。也就是说，信息的隐藏促进了软件的复用。
