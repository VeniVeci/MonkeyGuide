## 策略模式

为什么为True 但是不会进去呢

因为 encoding 不对

无折扣是GBK 编码  equals在使用的时候

![image.png](./assets/1700493010630-image.png)

你问我？你说呢？”大鸟笑道，“商场收银时如何促销，用打折还是返利，其实都是一些算法，用工厂来生成算法对象，这没有错，但算法本身只是一种策略，最重要的是这些算法是随时都可能互相替换的，这就是变化点，而封装变化点是我们面向对象的一种很重要的思维方式。我们来看看策略模式的结构图和基本代码。

策略模式的优点

1“策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能

2 策略模式的优点是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试[DPE]。”“每个算法可保证它没有错误，修改其中任一个时也不会影响其他的算法。这真的是非常好。”

# 第三章 单一职责原则

就是一个类最好职责明确

就一个类而言，应该仅有一个引起它变化的原因

比如我要修改这个代码的界面 那么就去界面类中修改

如果是修改算法 那就去算法类

# 第四章 考研求职两不误——开放-封闭原则

扩展的思想也是最重要的一种设计原则，它就是开放-封闭原则（The Open-Closeed Principle，简称OCP）或叫开-闭原则。

开放-封闭原则，是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改

## 如何应对变化

小菜：“啊，有道理。所以，我们尽量应在设计时，考虑到需求的种种变化，把问题想得全了，就不会因为需求一来，手足无措。”大鸟：“哪有那么容易，如果什么问题都考虑得到，那不就成了未卜先知，这是不可能的。需求时常会在你想不到的地方出现，让你防不胜防。”小菜：“那我们应该怎么做？”大鸟：“开放-封闭原则的意思就是说，你设计的时候，时刻要考虑，尽量让这个类是足够好，写好了就不要去修改了，如果新需求来，我们增加一些类就完事了，原来的代码能不动则不动。

### 案例

大鸟：“在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化[ASD]。比如，我之前让你写的加法程序，你很快在一个client类中就完成，此时变化还没有发生。然后我让你加一个减法功能，你发现，增加功能需要修改原来这个类，这就违背了今天讲到的‘开放-封闭原则’，于是你就该考虑重构程序，增加一个抽象的运算类，通过一些面向对象的手段，如继承，多态等来隔离具体加法、减法与client耦合，需求依然可以满足，还能应对变化。这时我又要你再加乘除法功能，你就不需要再去更改client以及加法减法的类了，而是增加乘法和除法子类就可。即面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码[ASD]。这就是‘开放-封闭原则’的精神所在。”（样例代码见第1章）

# 第五章 会修电脑不会修收音机？——依赖倒转原则

“蓝屏通常是内存本身有问题或内存与主板不兼容，主板不容易换，但内存更换起来很容易。”“如果是别的部件坏了，比如硬盘，显卡，光驱等，是否也只需要更换就可以了？”“是呀，确实很方便，只需要懂一点点计算机知识，就可以试着修电脑了。”

面向对象的四个好处？”“这个我记得最牢了，就是活字印刷那个例子呗。是可维护、可扩展、可复用和灵活性好。

CPU的强内聚的确是强。但它又独自成为了产品，在千千万万的电脑主板上插上就可以使用，这是什么原因？”大鸟又问。“因为CPU的对外都是针脚式或触点式等标准的接口。啊，我明白了，这就是接口的最大好处。CPU只需要把接口定义好，内部再复杂我也不让外界知道，而主板只需要预留与CPU针脚的插槽就可以了。”

PC的接口是有限的，所以扩展有限，软件系统设计得好，却可以无限地扩展。这两个原则我们之前都已经提过了。这里需要重点讲讲一个新的原则，叫依赖倒转原则，也有翻译成依赖倒置原则的。”大鸟接着讲道，“依赖倒转原则，原话解释是抽象不应该依赖细节，细节应该依赖于抽象，这话绕口，说白了，就是要针对接口编程，不要对实现编程，无论主板、CPU、内存、硬盘都是在针对接口设计的，如果针对实现来设计，内存就要对应到具体的某个品牌的主板，那就会出现换内存需要把主板也换了的尴尬

依赖倒转原则A．高层模块不应该依赖低层模块。两个都应该依赖抽象。B．抽象不应该依赖细节。细节应该依赖抽象。[ASD]

如果不管高层模块还是低层模块，它们都依赖于抽象，具体一点就是接口或抽象类，只要接口是稳定的，那么任何一个的更改都不用担心其他受到影响，这就使得无论高层模块还是低层模块都可以很容易地被复用。这才是最好的办法。”

依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了[ASD]。”“是的是的，我听说很多银行目前还是纯C语言的面向过程开发，非常不灵活，维护成本是很高昂的。”“那也是没办法的，银行系统哪是说换就换的，所以现在是大力鼓励年轻人学设计模式，直接面向对象的设计和编程，从大的方向上讲，这是国家大力发展生产力的很大保障呀。”

## 里氏代换原则

“里氏代换原则是Barbara Liskov女士在1988年发表的[ASD]，具体的数学定义比较复杂，你可以查相关资料，它的白话翻译就是一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化，简单地说，子类型必须能够替换掉它们的父类型[ASD]。”里氏代换原则（LSP）：子类型必须能够替换掉它们的父类型。[ASD]“这好像是学继承时就要理解的概念，子类继承了父类，所以子类可以以父类的身份出现。”“是的，我问你个问题，如果在面向对象设计时，一个是鸟类，一个是企鹅类，如果鸟是可以飞的，企鹅不会飞，那么企鹅是鸟吗？企鹅可以继承鸟这个类吗”“企鹅是一种特殊的鸟，尽管不能飞，但它也是鸟呀，当然可以继承。”“哈，你上当了，我说的是在面向对象设计时，那就意味着什么呢？子类拥有父类所有非private的行为和属性。鸟会飞，而企鹅不会飞。尽管在生物学分类上，企鹅是一种鸟，但在编程世界里，企鹅不能以父类——鸟的身份出现，因为前提说所有鸟都能飞，而企鹅飞不了，所以，企鹅不能继承鸟类。”

# 第6章　穿什么有这么重要？——装饰模式

要求你写一个可以给人搭配不同的服饰的系统，比如类似QQ、网络游戏或论坛都有的Avatar系统。你怎么开发

装饰者模式

装饰模式（Decorator），动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。[DP]“啊，装饰这词真好，无论衣服、鞋子、领带、披风其实都可以理解为对人的装饰。”

装饰模式的优点我总结下来就是，把类中的装饰功能从类中搬移去除，这样可以简化原有的类。”“是的，这样做更大的好处就是有效地把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复的装饰逻辑。”

# 第7章　为别人做嫁衣——代理模式

代理模式   java中就是 invoke

可以用来增强代码

aop就用到了

怎么做到

需要反射

既然都可以增强功能  那么

## 和装饰者模式的区别

## 应用场景

“那代理模式都用在一些什么场合呢？”小菜问道。“一般来说分为几种，第一，远程代理，也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实[DP]。”

# 第11章　无熟人难办事？——迪米特法则

迪米特法则（LoD），如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。

“迪米特法则首先强调的前提是在类的结构设计上，每一个类都应当尽量降低成员的访问权限[J&DP]，也就是说，一个类包装好自己的private状态，不需要让别的类知道的字段或行为就不要公开。”“哦，是的，需要公开的字段，通常就用属性来体现了。**这不是封装的思想吗？**

同样道理，**我们在程序设计时，类之间的耦合越弱，越有利于复用，**一个处在弱耦合的类被修改，不会对有关系的类造成波及。也就是说，信息的隐藏促进了软件的复用。

就是在访问一个类时   不需要知道很多东西 就能调用

**典型的api就是这样的**

使用的时候很方便

不需要自己去调节和设置

# 第12章　牛市股票还会亏钱？——外观模式

外观模式（Facade），为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用

dispatchservlet

![image.png](./assets/1701666149066-image.png)

“对于面向对象有一定基础的朋友，即使没有听说过外观模式，也完全有可能在很多时候使用它，因为它完美地体现了依赖倒转原则和迪米特法则的思想，所以是非常常用的模式之一。”

“那外观模式在什么时候使用最好呢？”小菜问道。“这要分三个阶段来说，首先，在设计初期阶段，应该要有意识的将不同的两个层分离，比如经典的三层架构，就需要考虑在数据访问层和业务逻辑层、业务逻辑层和表示层的层**与层之间建立外观Facade**，这样可以为复杂的子系统提供一个简单的接口，使得耦合大大降低。其次，在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，大多数的模式使用时也都会产生很多很小的类，这本是好事，但也给外部调用它们的用户程序带来了使用上的困难，增加外观Facade可以提供一个简单的接口，减少它们之间的依赖。第三，在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了，但因为它包含非常重要的功能，新的需求开发必须要依赖于它。此时用外观模式Facade也是非常合适的。你可以为新系统开发一个外观Facade类，来提供设计粗糙或高度复杂的遗留代码的比较清晰简单的接口，让新系统与Facade对象交互，Facade与遗留代码交互所有复杂的工作。

![image.png](./assets/1701666284237-image.png)

# 第13章　好菜每回味不同——建造者模式

一些类有固定的构建步骤

而且比较麻烦

就可以用建造者模式

指挥者  具体的建造者  抽象的建造者

![image.png](./assets/1701696462059-image.png)

如果你需要将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示的意图时，我们需要应用于一个设计模式，‘建造者（Builder）模式’，又叫生成器模式。建造者模式可以将一个产品的内部表象与产品的生成过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。如果我们用了建造者模式，那么用户就只需指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需知道了。”

怎么理解“但对象内部的构建通常面临着复杂的变化。”这句话

这句话的意思是，在使用建造者模式时，通常是因为要创建的对象内部的构建方式可能会面临复杂的变化。这是因为对象的构建不是一成不变的，可能会随着需求的变化而发生调整，而建造者模式可以更灵活地应对这些变化。

举个例子来说明：

假设有一个汽车制造的场景，汽车对象的构建涉及到引擎、车轮、车身等部件的组装。现在，汽车的制造需要根据不同的市场需求来定制，可能有豪华版、运动版、经济版等不同类型的汽车。

使用建造者模式，可以定义一个通用的汽车建造者接口，然后针对每种类型的汽车，实现具体的建造者，负责构建该类型汽车的各个部件。建造者模式将对象的构建细节封装在具体的建造者中，使得变化不同类型汽车的构建方式时，只需要定义新的具体建造者而不需要修改客户端代码。

[建造者模式——结合案例，深入浅出 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/143101326)

## 简化版的建造者模式

这个时候简化版的建造者模式站出来了

## ****采用链式编程的方式****

这种模式更加灵活，更加符合定义

既然Director是变化的，并且其实在生活中我们自己本身就是Director,所以这个时候我们可以**把Director这个角色去掉**，因为我们自身就是指导者

* 产品（product）

```java
public class KFC {
    //套餐必点
    private String hamburger;
    private String chips;

    //套餐选点
    private String chicken;
    private String cola;
    private String pizza;
    public KFC(String hamburger,String chips){
        this.hamburger = hamburger;
        this.hamburger = chips;
    }
    public void setChicken(String chicken) {
        this.chicken = chicken;
    }

    public void setCola(String cola) {
        this.cola = cola;
    }

    public void setPizza(String pizza) {
        this.pizza = pizza;
    }
```

* 抽象建造者（builder）

```java
public abstract class Builder {
        abstract Builder setChicken();
        abstract Builder setCola();
        abstract Builder setPizza();
        abstract KFC getKFC();
}
```

* 具体建造者(ConcreteBuilder)

```java
public class ConcreteBuilder extends Builder {
    KFC kfc;
    public ConcreteBuilder(String hamburger,String chips){
        kfc = new KFC(hamburger,chips);
    }
    @Override
    Builder setChicken() {
        kfc.setChicken("鸡腿");
        return this;
    }

    @Override
    Builder setCola() {
        kfc.setCola("可乐");
        return this;
    }

    @Override
    Builder setPizza() {
        kfc.setPizza("披萨");
        return this;
    }

    @Override
    KFC getKFC() {
        return kfc;
    }
}
```

* 测试

```java
public class BTest {
    public static void main(String[] args) {
       KFC kfc = new ConcreteBuilder("汉堡","薯条").setChicken().setCola().getKFC();
    }
}
```

asa

# 第20章　想走？可以！先买票——迭代器模式

迭代器模式（Iterator），提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示

当你需要访问一个聚集对象，而且不管这些对象是什么都需要遍历的时候，你就应该考虑用迭代器模式。另外，售票员从车头到车尾来售票，也可以从车尾向车头来售票，也就是说，你需要对聚集有多种方式遍历时，可以考虑用迭代器模式

本来这个模式还是有点意思的，不过现今来看迭代器模式实用价值远不如学习价值大了，MartinFlower甚至在自己的网站上提出**撤销此模式**。****因为现在高级编程语言如C#、JAVA等本身已经把这个模式做在语言中了。**

”“哦，是什么？”“哈，foreach in你熟悉吗？”“啊，原来是它，没错没错，它就是不需要知道集合对象是什么，就可以遍历所有的对象的循环工具，非常好用。”

![image.png](./assets/1701752939770-image.png)

总地来说，迭代器（Iterator）模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。迭代器模式在访问数组、集合、列表等数据时，尤其是数据库数据操作时，是非常普遍的应用，但由于它太普遍了，所以各种高级语言都对它进行了封装，所以反而给人感觉此模式本身不太常用了



# 第21章　有些类也需计划生育——单例模式

“通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法
